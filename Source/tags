!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A_BLOCK_LINK	portable/MemMang/heap_2.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
A_BLOCK_LINK	portable/MemMang/heap_4.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
A_BLOCK_LINK	portable/MemMang/heap_5.c	/^typedef struct A_BLOCK_LINK$/;"	s	file:
BaseType_t	portable/GCC/RaspberryPi/portmacro.h	/^typedef long BaseType_t;$/;"	t
BlockLink_t	portable/MemMang/heap_2.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
BlockLink_t	portable/MemMang/heap_4.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
BlockLink_t	portable/MemMang/heap_5.c	/^} BlockLink_t;$/;"	t	typeref:struct:A_BLOCK_LINK	file:
CO_ROUTINE_H	include/croutine.h	71;"	d
CRCB_t	include/croutine.h	/^} CRCB_t; \/* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. *\/$/;"	t	typeref:struct:corCoRoutineControlBlock
CallbackParameters_t	timers.c	/^} CallbackParameters_t;$/;"	t	typeref:struct:tmrCallbackParameters	file:
CoRoutineHandle_t	include/croutine.h	/^typedef void * CoRoutineHandle_t;$/;"	t
DEPRECATED_DEFINITIONS_H	include/deprecated_definitions.h	71;"	d
DaemonTaskMessage_t	timers.c	/^} DaemonTaskMessage_t;$/;"	t	typeref:struct:tmrTimerQueueMessage	file:
EVENT_GROUPS_H	include/event_groups.h	71;"	d
EventBits_t	include/event_groups.h	/^typedef TickType_t EventBits_t;$/;"	t
EventGroupHandle_t	include/event_groups.h	/^typedef void * EventGroupHandle_t;$/;"	t
EventGroup_t	event_groups.c	/^} EventGroup_t;$/;"	t	typeref:struct:xEventGroupDefinition	file:
FreeRTOS_IRQ_Handler	portable/GCC/RaspberryPi/portASM.s	/^FreeRTOS_IRQ_Handler:$/;"	l
FreeRTOS_SVC_Handler	portable/GCC/RaspberryPi/portASM.s	/^FreeRTOS_SVC_Handler:$/;"	l
FreeRTOS_Tick_Handler	portable/GCC/RaspberryPi/port.c	/^void FreeRTOS_Tick_Handler( void )$/;"	f
HeapRegion	include/portable.h	/^typedef struct HeapRegion$/;"	s
HeapRegion_t	include/portable.h	/^} HeapRegion_t;$/;"	t	typeref:struct:HeapRegion
INCLUDE_eTaskGetState	include/FreeRTOS.h	202;"	d
INCLUDE_uxTaskGetStackHighWaterMark	include/FreeRTOS.h	198;"	d
INCLUDE_uxTaskPriorityGet	include/FreeRTOS.h	158;"	d
INCLUDE_vTaskDelay	include/FreeRTOS.h	174;"	d
INCLUDE_vTaskDelayUntil	include/FreeRTOS.h	170;"	d
INCLUDE_vTaskDelete	include/FreeRTOS.h	162;"	d
INCLUDE_vTaskPrioritySet	include/FreeRTOS.h	154;"	d
INCLUDE_vTaskSuspend	include/FreeRTOS.h	166;"	d
INCLUDE_xQueueGetMutexHolder	include/FreeRTOS.h	186;"	d
INCLUDE_xSemaphoreGetMutexHolder	include/FreeRTOS.h	190;"	d
INCLUDE_xTaskAbortDelay	include/FreeRTOS.h	182;"	d
INCLUDE_xTaskGetCurrentTaskHandle	include/FreeRTOS.h	218;"	d
INCLUDE_xTaskGetHandle	include/FreeRTOS.h	194;"	d
INCLUDE_xTaskGetIdleTaskHandle	include/FreeRTOS.h	178;"	d
INCLUDE_xTaskGetSchedulerState	include/FreeRTOS.h	214;"	d
INCLUDE_xTaskResumeFromISR	include/FreeRTOS.h	206;"	d
INCLUDE_xTimerPendFunctionCall	include/FreeRTOS.h	210;"	d
INC_FREERTOS_H	include/FreeRTOS.h	71;"	d
INC_TASK_H	include/task.h	72;"	d
LIST_H	include/list.h	103;"	d
ListItem_t	include/list.h	/^typedef struct xLIST_ITEM ListItem_t;					\/* For some reason lint wants this as two separate definitions. *\/$/;"	t	typeref:struct:xLIST_ITEM
List_t	include/list.h	/^} List_t;$/;"	t	typeref:struct:xLIST
MPU_PROTOTYPES_H	include/mpu_prototypes.h	80;"	d
MPU_WRAPPERS_H	include/mpu_wrappers.h	71;"	d
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	event_groups.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	event_groups.c	88;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_1.c	83;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_1.c	88;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_2.c	84;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_2.c	89;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_3.c	87;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_3.c	92;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_4.c	83;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_4.c	88;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_5.c	117;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	portable/MemMang/heap_5.c	122;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	queue.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	queue.c	90;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	tasks.c	77;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	tasks.c	89;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	timers.c	76;"	d	file:
MPU_WRAPPERS_INCLUDED_FROM_API_FILE	timers.c	91;"	d	file:
MemoryRegion_t	include/task.h	/^} MemoryRegion_t;$/;"	t	typeref:struct:xMEMORY_REGION
MiniListItem_t	include/list.h	/^typedef struct xMINI_LIST_ITEM MiniListItem_t;$/;"	t	typeref:struct:xMINI_LIST_ITEM
PORTABLE_H	include/portable.h	75;"	d
PORTMACRO_H	portable/GCC/RaspberryPi/portmacro.h	71;"	d
PRIVILEGED_DATA	include/mpu_wrappers.h	187;"	d
PRIVILEGED_DATA	include/mpu_wrappers.h	194;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	181;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	186;"	d
PRIVILEGED_FUNCTION	include/mpu_wrappers.h	193;"	d
PROJDEFS_H	include/projdefs.h	71;"	d
PendedFunction_t	include/timers.h	/^typedef void (*PendedFunction_t)( void *, uint32_t );$/;"	t
QUEUE_H	include/queue.h	72;"	d
QUEUE_REGISTRY_ITEM	queue.c	/^	typedef struct QUEUE_REGISTRY_ITEM$/;"	s	file:
QueueDefinition	queue.c	/^typedef struct QueueDefinition$/;"	s	file:
QueueHandle_t	include/queue.h	/^typedef void * QueueHandle_t;$/;"	t
QueueRegistryItem_t	queue.c	/^	typedef xQueueRegistryItem QueueRegistryItem_t;$/;"	t	file:
QueueSetHandle_t	include/queue.h	/^typedef void * QueueSetHandle_t;$/;"	t
QueueSetMemberHandle_t	include/queue.h	/^typedef void * QueueSetMemberHandle_t;$/;"	t
Queue_t	queue.c	/^typedef xQUEUE Queue_t;$/;"	t	file:
SEMAPHORE_H	include/semphr.h	71;"	d
STACK_MACROS_H	include/StackMacros.h	71;"	d
SemaphoreHandle_t	include/semphr.h	/^typedef QueueHandle_t SemaphoreHandle_t;$/;"	t
StackType_t	portable/GCC/RaspberryPi/portmacro.h	/^typedef portSTACK_TYPE StackType_t;$/;"	t
StaticEventGroup_t	include/FreeRTOS.h	/^} StaticEventGroup_t;$/;"	t	typeref:struct:xSTATIC_EVENT_GROUP
StaticListItem_t	include/FreeRTOS.h	/^typedef struct xSTATIC_LIST_ITEM StaticListItem_t;$/;"	t	typeref:struct:xSTATIC_LIST_ITEM
StaticList_t	include/FreeRTOS.h	/^} StaticList_t;$/;"	t	typeref:struct:xSTATIC_LIST
StaticMiniListItem_t	include/FreeRTOS.h	/^typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;$/;"	t	typeref:struct:xSTATIC_MINI_LIST_ITEM
StaticQueue_t	include/FreeRTOS.h	/^} StaticQueue_t;$/;"	t	typeref:struct:xSTATIC_QUEUE
StaticSemaphore_t	include/FreeRTOS.h	/^typedef StaticQueue_t StaticSemaphore_t;$/;"	t
StaticTask_t	include/FreeRTOS.h	/^} StaticTask_t;$/;"	t	typeref:struct:xSTATIC_TCB
StaticTimer_t	include/FreeRTOS.h	/^} StaticTimer_t;$/;"	t	typeref:struct:xSTATIC_TIMER
TCB_t	tasks.c	/^typedef tskTCB TCB_t;$/;"	t	file:
TIMERS_H	include/timers.h	72;"	d
TaskFunction_t	include/projdefs.h	/^typedef void (*TaskFunction_t)( void * );$/;"	t
TaskHandle_t	include/task.h	/^typedef void * TaskHandle_t;$/;"	t
TaskHookFunction_t	include/task.h	/^typedef BaseType_t (*TaskHookFunction_t)( void * );$/;"	t
TaskParameters_t	include/task.h	/^} TaskParameters_t;$/;"	t	typeref:struct:xTASK_PARAMETERS
TaskStatus_t	include/task.h	/^} TaskStatus_t;$/;"	t	typeref:struct:xTASK_STATUS
TickType_t	portable/GCC/RaspberryPi/portmacro.h	/^typedef uint32_t TickType_t;$/;"	t
TimeOut_t	include/task.h	/^} TimeOut_t;$/;"	t	typeref:struct:xTIME_OUT
TimerCallbackFunction_t	include/timers.h	/^typedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );$/;"	t
TimerHandle_t	include/timers.h	/^typedef void * TimerHandle_t;$/;"	t
TimerParameter_t	timers.c	/^} TimerParameter_t;$/;"	t	typeref:struct:tmrTimerParameters	file:
Timer_t	timers.c	/^typedef xTIMER Timer_t;$/;"	t	file:
UBaseType_t	portable/GCC/RaspberryPi/portmacro.h	/^typedef unsigned long UBaseType_t;$/;"	t
cRxLock	queue.c	/^	volatile int8_t cRxLock;		\/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
cTxLock	queue.c	/^	volatile int8_t cTxLock;		\/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. *\/$/;"	m	struct:QueueDefinition	file:
configADJUSTED_HEAP_SIZE	portable/MemMang/heap_1.c	95;"	d	file:
configADJUSTED_HEAP_SIZE	portable/MemMang/heap_2.c	96;"	d	file:
configAPPLICATION_ALLOCATED_HEAP	include/FreeRTOS.h	764;"	d
configASSERT	include/FreeRTOS.h	276;"	d
configASSERT_DEFINED	include/FreeRTOS.h	277;"	d
configASSERT_DEFINED	include/FreeRTOS.h	279;"	d
configCHECK_FOR_STACK_OVERFLOW	include/FreeRTOS.h	408;"	d
configENABLE_BACKWARD_COMPATIBILITY	include/FreeRTOS.h	820;"	d
configEXPECTED_IDLE_TIME_BEFORE_SLEEP	include/FreeRTOS.h	700;"	d
configGENERATE_RUN_TIME_STATS	include/FreeRTOS.h	662;"	d
configIDLE_SHOULD_YIELD	include/FreeRTOS.h	268;"	d
configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS	include/FreeRTOS.h	732;"	d
configLIST_VOLATILE	include/list.h	134;"	d
configMAX_TASK_NAME_LEN	include/FreeRTOS.h	264;"	d
configNUM_THREAD_LOCAL_STORAGE_POINTERS	include/FreeRTOS.h	236;"	d
configPOST_SLEEP_PROCESSING	include/FreeRTOS.h	716;"	d
configPRE_SLEEP_PROCESSING	include/FreeRTOS.h	712;"	d
configQUEUE_REGISTRY_SIZE	include/FreeRTOS.h	320;"	d
configSUPPORT_DYNAMIC_ALLOCATION	include/FreeRTOS.h	782;"	d
configSUPPORT_STATIC_ALLOCATION	include/FreeRTOS.h	777;"	d
configUSE_ALTERNATIVE_API	include/FreeRTOS.h	256;"	d
configUSE_APPLICATION_TASK_TAG	include/FreeRTOS.h	232;"	d
configUSE_COUNTING_SEMAPHORES	include/FreeRTOS.h	252;"	d
configUSE_CO_ROUTINES	include/FreeRTOS.h	150;"	d
configUSE_DAEMON_TASK_STARTUP_HOOK	include/FreeRTOS.h	228;"	d
configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES	include/projdefs.h	101;"	d
configUSE_MALLOC_FAILED_HOOK	include/FreeRTOS.h	684;"	d
configUSE_MUTEXES	include/FreeRTOS.h	244;"	d
configUSE_NEWLIB_REENTRANT	include/FreeRTOS.h	108;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	include/FreeRTOS.h	760;"	d
configUSE_PORT_OPTIMISED_TASK_SELECTION	portable/GCC/RaspberryPi/portmacro.h	191;"	d
configUSE_QUEUE_SETS	include/FreeRTOS.h	720;"	d
configUSE_RECURSIVE_MUTEXES	include/FreeRTOS.h	240;"	d
configUSE_STATS_FORMATTING_FUNCTIONS	include/FreeRTOS.h	736;"	d
configUSE_TASK_FPU_SUPPORT	include/FreeRTOS.h	861;"	d
configUSE_TASK_NOTIFICATIONS	include/FreeRTOS.h	768;"	d
configUSE_TICKLESS_IDLE	include/FreeRTOS.h	708;"	d
configUSE_TIMERS	include/FreeRTOS.h	248;"	d
configUSE_TIME_SLICING	include/FreeRTOS.h	728;"	d
configUSE_TRACE_FACILITY	include/FreeRTOS.h	744;"	d
corCoRoutineControlBlock	include/croutine.h	/^typedef struct corCoRoutineControlBlock$/;"	s
corINITIAL_STATE	croutine.c	100;"	d	file:
crCOROUTINE_CODE	include/croutine.h	/^typedef void (*crCOROUTINE_CODE)( CoRoutineHandle_t, UBaseType_t );$/;"	t
crDELAY	include/croutine.h	332;"	d
crEND	include/croutine.h	277;"	d
crQUEUE_RECEIVE	include/croutine.h	514;"	d
crQUEUE_RECEIVE_FROM_ISR	include/croutine.h	736;"	d
crQUEUE_SEND	include/croutine.h	422;"	d
crQUEUE_SEND_FROM_ISR	include/croutine.h	623;"	d
crSET_STATE0	include/croutine.h	283;"	d
crSET_STATE1	include/croutine.h	284;"	d
crSTART	include/croutine.h	246;"	d
eAbortSleep	include/task.h	/^	eAbortSleep = 0,		\/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. *\/$/;"	e	enum:__anon5
eBlocked	include/task.h	/^	eBlocked,		\/* The task being queried is in the Blocked state. *\/$/;"	e	enum:__anon3
eCurrentState	include/task.h	/^	eTaskState eCurrentState;		\/* The state in which the task existed when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
eDeleted	include/task.h	/^	eDeleted,		\/* The task being queried has been deleted, but its TCB has not yet been freed. *\/$/;"	e	enum:__anon3
eIncrement	include/task.h	/^	eIncrement,					\/* Increment the task's notification value. *\/$/;"	e	enum:__anon4
eInvalid	include/task.h	/^	eInvalid			\/* Used as an 'invalid state' value. *\/$/;"	e	enum:__anon3
eNoAction	include/task.h	/^	eNoAction = 0,				\/* Notify the task without updating its notify value. *\/$/;"	e	enum:__anon4
eNoTasksWaitingTimeout	include/task.h	/^	eNoTasksWaitingTimeout	\/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. *\/$/;"	e	enum:__anon5
eNotifyAction	include/task.h	/^} eNotifyAction;$/;"	t	typeref:enum:__anon4
eReady	include/task.h	/^	eReady,			\/* The task being queried is in a read or pending ready list. *\/$/;"	e	enum:__anon3
eRunning	include/task.h	/^	eRunning = 0,	\/* A task is querying the state of itself, so must be running. *\/$/;"	e	enum:__anon3
eSetBits	include/task.h	/^	eSetBits,					\/* Set bits in the task's notification value. *\/$/;"	e	enum:__anon4
eSetValueWithOverwrite	include/task.h	/^	eSetValueWithOverwrite,		\/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. *\/$/;"	e	enum:__anon4
eSetValueWithoutOverwrite	include/task.h	/^	eSetValueWithoutOverwrite	\/* Set the task's notification value if the previous value has been read by the task. *\/$/;"	e	enum:__anon4
eSleepModeStatus	include/task.h	/^} eSleepModeStatus;$/;"	t	typeref:enum:__anon5
eStandardSleep	include/task.h	/^	eStandardSleep,			\/* Enter a sleep mode that will not last any longer than the expected idle time. *\/$/;"	e	enum:__anon5
eSuspended	include/task.h	/^	eSuspended,		\/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *\/$/;"	e	enum:__anon3
eTaskConfirmSleepModeStatus	tasks.c	/^	eSleepModeStatus eTaskConfirmSleepModeStatus( void )$/;"	f
eTaskGetState	include/mpu_wrappers.h	100;"	d
eTaskGetState	tasks.c	/^	eTaskState eTaskGetState( TaskHandle_t xTask )$/;"	f
eTaskState	include/task.h	/^} eTaskState;$/;"	t	typeref:enum:__anon3
eTaskStateGet	include/FreeRTOS.h	824;"	d
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	include/projdefs.h	95;"	d
errQUEUE_BLOCKED	include/projdefs.h	96;"	d
errQUEUE_EMPTY	include/projdefs.h	91;"	d
errQUEUE_FULL	include/projdefs.h	92;"	d
errQUEUE_YIELD	include/projdefs.h	97;"	d
eventCLEAR_EVENTS_ON_EXIT_BIT	event_groups.c	94;"	d	file:
eventCLEAR_EVENTS_ON_EXIT_BIT	event_groups.c	99;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	event_groups.c	102;"	d	file:
eventEVENT_BITS_CONTROL_BYTES	event_groups.c	97;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	event_groups.c	100;"	d	file:
eventUNBLOCKED_DUE_TO_BIT_SET	event_groups.c	95;"	d	file:
eventWAIT_FOR_ALL_BITS	event_groups.c	101;"	d	file:
eventWAIT_FOR_ALL_BITS	event_groups.c	96;"	d	file:
exit_without_switch	portable/GCC/RaspberryPi/portASM.s	/^exit_without_switch:$/;"	l
heapBITS_PER_BYTE	portable/MemMang/heap_4.c	98;"	d	file:
heapBITS_PER_BYTE	portable/MemMang/heap_5.c	132;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_2.c	123;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_4.c	95;"	d	file:
heapMINIMUM_BLOCK_SIZE	portable/MemMang/heap_5.c	129;"	d	file:
heapSTRUCT_SIZE	portable/MemMang/heap_2.c	/^static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );$/;"	v	file:
listCURRENT_LIST_LENGTH	include/list.h	296;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	include/list.h	150;"	d
listFIRST_LIST_INTEGRITY_CHECK_VALUE	include/list.h	162;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	148;"	d
listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	160;"	d
listGET_END_MARKER	include/list.h	282;"	d
listGET_HEAD_ENTRY	include/list.h	266;"	d
listGET_ITEM_VALUE_OF_HEAD_ENTRY	include/list.h	258;"	d
listGET_LIST_ITEM_OWNER	include/list.h	230;"	d
listGET_LIST_ITEM_VALUE	include/list.h	249;"	d
listGET_NEXT	include/list.h	274;"	d
listGET_OWNER_OF_HEAD_ENTRY	include/list.h	348;"	d
listGET_OWNER_OF_NEXT_ENTRY	include/list.h	318;"	d
listIS_CONTAINED_WITHIN	include/list.h	359;"	d
listLIST_IS_EMPTY	include/list.h	291;"	d
listLIST_IS_INITIALISED	include/list.h	374;"	d
listLIST_ITEM_CONTAINER	include/list.h	367;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	include/list.h	151;"	d
listSECOND_LIST_INTEGRITY_CHECK_VALUE	include/list.h	163;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	149;"	d
listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	161;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	152;"	d
listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	166;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	include/list.h	154;"	d
listSET_LIST_INTEGRITY_CHECK_1_VALUE	include/list.h	168;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	include/list.h	155;"	d
listSET_LIST_INTEGRITY_CHECK_2_VALUE	include/list.h	169;"	d
listSET_LIST_ITEM_OWNER	include/list.h	221;"	d
listSET_LIST_ITEM_VALUE	include/list.h	239;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	153;"	d
listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	include/list.h	167;"	d
listTEST_LIST_INTEGRITY	include/list.h	157;"	d
listTEST_LIST_INTEGRITY	include/list.h	174;"	d
listTEST_LIST_ITEM_INTEGRITY	include/list.h	156;"	d
listTEST_LIST_ITEM_INTEGRITY	include/list.h	173;"	d
mtCOVERAGE_TEST_DELAY	include/FreeRTOS.h	752;"	d
mtCOVERAGE_TEST_MARKER	include/FreeRTOS.h	748;"	d
pcHead	queue.c	/^	int8_t *pcHead;					\/*< Points to the beginning of the queue storage area. *\/$/;"	m	struct:QueueDefinition	file:
pcName	include/task.h	/^	const char * const pcName;	\/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_PARAMETERS
pcQueueGetName	include/FreeRTOS.h	326;"	d
pcQueueGetName	include/mpu_wrappers.h	155;"	d
pcQueueGetName	queue.c	/^	const char *pcQueueGetName( QueueHandle_t xQueue ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
pcQueueGetQueueName	include/FreeRTOS.h	841;"	d
pcQueueName	queue.c	/^		const char *pcQueueName; \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
pcReadFrom	queue.c	/^		int8_t *pcReadFrom;			\/*< Points to the last place that a queued item was read from when the structure is used as a queue. *\/$/;"	m	union:QueueDefinition::__anon2	file:
pcTail	queue.c	/^	int8_t *pcTail;					\/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. *\/$/;"	m	struct:QueueDefinition	file:
pcTaskGetName	include/mpu_wrappers.h	109;"	d
pcTaskGetName	tasks.c	/^char *pcTaskGetName( TaskHandle_t xTaskToQuery ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
pcTaskGetTaskName	include/FreeRTOS.h	839;"	d
pcTaskName	include/task.h	/^	const char *pcTaskName;			\/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:xTASK_STATUS
pcTaskName	tasks.c	/^	char				pcTaskName[ configMAX_TASK_NAME_LEN ];\/*< Descriptive name given to the task when created.  Facilitates debugging only. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tskTaskControlBlock	file:
pcTimerGetName	include/mpu_wrappers.h	166;"	d
pcTimerGetName	timers.c	/^const char * pcTimerGetName( TimerHandle_t xTimer ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
pcTimerGetTimerName	include/FreeRTOS.h	840;"	d
pcTimerName	timers.c	/^	const char				*pcTimerName;		\/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. *\/ \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	m	struct:tmrTimerControl	file:
pcWriteTo	queue.c	/^	int8_t *pcWriteTo;				\/*< Points to the free next place in the storage area. *\/$/;"	m	struct:QueueDefinition	file:
pdFAIL	include/projdefs.h	90;"	d
pdFALSE	include/projdefs.h	86;"	d
pdFREERTOS_BIG_ENDIAN	include/projdefs.h	156;"	d
pdFREERTOS_ERRNO_EACCES	include/projdefs.h	121;"	d
pdFREERTOS_ERRNO_EADDRINUSE	include/projdefs.h	142;"	d
pdFREERTOS_ERRNO_EADDRNOTAVAIL	include/projdefs.h	146;"	d
pdFREERTOS_ERRNO_EAGAIN	include/projdefs.h	118;"	d
pdFREERTOS_ERRNO_EALREADY	include/projdefs.h	145;"	d
pdFREERTOS_ERRNO_EBADE	include/projdefs.h	134;"	d
pdFREERTOS_ERRNO_EBADF	include/projdefs.h	117;"	d
pdFREERTOS_ERRNO_EBUSY	include/projdefs.h	123;"	d
pdFREERTOS_ERRNO_ECANCELED	include/projdefs.h	151;"	d
pdFREERTOS_ERRNO_EEXIST	include/projdefs.h	124;"	d
pdFREERTOS_ERRNO_EFAULT	include/projdefs.h	122;"	d
pdFREERTOS_ERRNO_EFTYPE	include/projdefs.h	135;"	d
pdFREERTOS_ERRNO_EILSEQ	include/projdefs.h	150;"	d
pdFREERTOS_ERRNO_EINPROGRESS	include/projdefs.h	144;"	d
pdFREERTOS_ERRNO_EINTR	include/projdefs.h	114;"	d
pdFREERTOS_ERRNO_EINVAL	include/projdefs.h	129;"	d
pdFREERTOS_ERRNO_EIO	include/projdefs.h	115;"	d
pdFREERTOS_ERRNO_EISCONN	include/projdefs.h	147;"	d
pdFREERTOS_ERRNO_EISDIR	include/projdefs.h	128;"	d
pdFREERTOS_ERRNO_ENAMETOOLONG	include/projdefs.h	138;"	d
pdFREERTOS_ERRNO_ENMFILE	include/projdefs.h	136;"	d
pdFREERTOS_ERRNO_ENOBUFS	include/projdefs.h	140;"	d
pdFREERTOS_ERRNO_ENODEV	include/projdefs.h	126;"	d
pdFREERTOS_ERRNO_ENOENT	include/projdefs.h	113;"	d
pdFREERTOS_ERRNO_ENOMEDIUM	include/projdefs.h	149;"	d
pdFREERTOS_ERRNO_ENOMEM	include/projdefs.h	120;"	d
pdFREERTOS_ERRNO_ENOPROTOOPT	include/projdefs.h	141;"	d
pdFREERTOS_ERRNO_ENOSPC	include/projdefs.h	130;"	d
pdFREERTOS_ERRNO_ENOTCONN	include/projdefs.h	148;"	d
pdFREERTOS_ERRNO_ENOTDIR	include/projdefs.h	127;"	d
pdFREERTOS_ERRNO_ENOTEMPTY	include/projdefs.h	137;"	d
pdFREERTOS_ERRNO_ENXIO	include/projdefs.h	116;"	d
pdFREERTOS_ERRNO_EOPNOTSUPP	include/projdefs.h	139;"	d
pdFREERTOS_ERRNO_EROFS	include/projdefs.h	132;"	d
pdFREERTOS_ERRNO_ESPIPE	include/projdefs.h	131;"	d
pdFREERTOS_ERRNO_ETIMEDOUT	include/projdefs.h	143;"	d
pdFREERTOS_ERRNO_EUNATCH	include/projdefs.h	133;"	d
pdFREERTOS_ERRNO_EWOULDBLOCK	include/projdefs.h	119;"	d
pdFREERTOS_ERRNO_EXDEV	include/projdefs.h	125;"	d
pdFREERTOS_ERRNO_NONE	include/projdefs.h	112;"	d
pdFREERTOS_LITTLE_ENDIAN	include/projdefs.h	155;"	d
pdINTEGRITY_CHECK_VALUE	include/projdefs.h	105;"	d
pdINTEGRITY_CHECK_VALUE	include/projdefs.h	107;"	d
pdMS_TO_TICKS	include/projdefs.h	83;"	d
pdPASS	include/projdefs.h	89;"	d
pdTASK_CODE	include/FreeRTOS.h	847;"	d
pdTASK_HOOK_CODE	include/FreeRTOS.h	837;"	d
pdTRUE	include/projdefs.h	87;"	d
portAPSR_MODE_BITS_MASK	portable/GCC/RaspberryPi/port.c	109;"	d	file:
portAPSR_USER_MODE	portable/GCC/RaspberryPi/port.c	113;"	d	file:
portASSERT_IF_INTERRUPT_PRIORITY_INVALID	include/FreeRTOS.h	740;"	d
portASSERT_IF_IN_ISR	include/FreeRTOS.h	756;"	d
portBASE_TYPE	portable/GCC/RaspberryPi/portmacro.h	94;"	d
portBYTE_ALIGNMENT	portable/GCC/RaspberryPi/portmacro.h	112;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	102;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	106;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	110;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	114;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	118;"	d
portBYTE_ALIGNMENT_MASK	include/portable.h	98;"	d
portCHAR	portable/GCC/RaspberryPi/portmacro.h	88;"	d
portCLEAN_UP_TCB	include/FreeRTOS.h	308;"	d
portCLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	304;"	d
portCLEAR_INTERRUPT_MASK_FROM_ISR	portable/GCC/RaspberryPi/portmacro.h	167;"	d
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS	include/FreeRTOS.h	680;"	d
portCRITICAL_NESTING_IN_TCB	include/FreeRTOS.h	260;"	d
portDISABLE_INTERRUPTS	portable/GCC/RaspberryPi/portmacro.h	152;"	d
portDOUBLE	portable/GCC/RaspberryPi/portmacro.h	90;"	d
portENABLE_INTERRUPTS	portable/GCC/RaspberryPi/portmacro.h	151;"	d
portEND_SWITCHING_ISR	portable/GCC/RaspberryPi/portmacro.h	119;"	d
portENTER_CRITICAL	portable/GCC/RaspberryPi/portmacro.h	149;"	d
portEOIStub	portable/GCC/RaspberryPi/portISR.c	/^volatile uint32_t portEOIStub;$/;"	v
portEXIT_CRITICAL	portable/GCC/RaspberryPi/portmacro.h	150;"	d
portFLOAT	portable/GCC/RaspberryPi/portmacro.h	89;"	d
portGET_HIGHEST_PRIORITY	portable/GCC/RaspberryPi/portmacro.h	202;"	d
portINITIAL_SPSR	portable/GCC/RaspberryPi/port.c	104;"	d	file:
portINLINE	portable/GCC/RaspberryPi/portmacro.h	207;"	d
portINLINE_SET_INTERRUPT_MASK_FROM_ISR	portable/GCC/RaspberryPi/portmacro.h	/^__attribute__( ( always_inline ) ) static __inline uint32_t portINLINE_SET_INTERRUPT_MASK_FROM_ISR( void )$/;"	f
portINTERRUPT_ENABLE_BIT	portable/GCC/RaspberryPi/portmacro.h	145;"	d
portLONG	portable/GCC/RaspberryPi/portmacro.h	91;"	d
portLOWEST_INTERRUPT_PRIORITY	portable/GCC/RaspberryPi/portmacro.h	186;"	d
portLOWEST_USABLE_INTERRUPT_PRIORITY	portable/GCC/RaspberryPi/portmacro.h	187;"	d
portMAX_DELAY	portable/GCC/RaspberryPi/portmacro.h	101;"	d
portNOP	portable/GCC/RaspberryPi/portmacro.h	206;"	d
portNO_CRITICAL_NESTING	portable/GCC/RaspberryPi/port.c	94;"	d	file:
portNO_FLOATING_POINT_CONTEXT	portable/GCC/RaspberryPi/port.c	101;"	d	file:
portNUM_CONFIGURABLE_REGIONS	include/portable.h	126;"	d
portPOINTER_SIZE_TYPE	include/FreeRTOS.h	330;"	d
portPRESCALE_VALUE	portable/GCC/RaspberryPi/portISR.c	11;"	d	file:
portPRE_TASK_DELETE_HOOK	include/FreeRTOS.h	312;"	d
portPRIVILEGE_BIT	include/FreeRTOS.h	688;"	d
portRECORD_READY_PRIORITY	portable/GCC/RaspberryPi/portmacro.h	197;"	d
portRESET_READY_PRIORITY	portable/GCC/RaspberryPi/portmacro.h	198;"	d
portRESET_READY_PRIORITY	tasks.c	197;"	d	file:
portSETUP_TCB	include/FreeRTOS.h	316;"	d
portSET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	300;"	d
portSET_INTERRUPT_MASK_FROM_ISR	portable/GCC/RaspberryPi/portmacro.h	166;"	d
portSHORT	portable/GCC/RaspberryPi/portmacro.h	92;"	d
portSTACK_GROWTH	portable/GCC/RaspberryPi/portmacro.h	110;"	d
portSTACK_TYPE	portable/GCC/RaspberryPi/portmacro.h	93;"	d
portSUPPRESS_TICKS_AND_SLEEP	include/FreeRTOS.h	696;"	d
portTASK_FUNCTION	portable/GCC/RaspberryPi/portmacro.h	175;"	d
portTASK_FUNCTION	tasks.c	/^static portTASK_FUNCTION( prvIdleTask, pvParameters )$/;"	f	file:
portTASK_FUNCTION_PROTO	portable/GCC/RaspberryPi/portmacro.h	174;"	d
portTASK_RETURN_ADDRESS	portable/GCC/RaspberryPi/port.c	119;"	d	file:
portTASK_RETURN_ADDRESS	portable/GCC/RaspberryPi/port.c	121;"	d	file:
portTASK_USES_FLOATING_POINT	include/FreeRTOS.h	724;"	d
portTASK_USES_FLOATING_POINT	portable/GCC/RaspberryPi/portmacro.h	184;"	d
portTHUMB_MODE_ADDRESS	portable/GCC/RaspberryPi/port.c	106;"	d	file:
portTHUMB_MODE_BIT	portable/GCC/RaspberryPi/port.c	105;"	d	file:
portTICK_PERIOD_MS	portable/GCC/RaspberryPi/portmacro.h	111;"	d
portTICK_RATE_MS	include/FreeRTOS.h	838;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	807;"	d
portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	814;"	d
portTICK_TYPE_ENTER_CRITICAL	include/FreeRTOS.h	804;"	d
portTICK_TYPE_ENTER_CRITICAL	include/FreeRTOS.h	811;"	d
portTICK_TYPE_EXIT_CRITICAL	include/FreeRTOS.h	805;"	d
portTICK_TYPE_EXIT_CRITICAL	include/FreeRTOS.h	812;"	d
portTICK_TYPE_IS_ATOMIC	include/FreeRTOS.h	772;"	d
portTICK_TYPE_IS_ATOMIC	portable/GCC/RaspberryPi/portmacro.h	105;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	806;"	d
portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR	include/FreeRTOS.h	813;"	d
portTickType	include/FreeRTOS.h	825;"	d
portUSING_MPU_WRAPPERS	include/mpu_wrappers.h	195;"	d
portYIELD	portable/GCC/RaspberryPi/portmacro.h	130;"	d
portYIELD_FROM_ISR	portable/GCC/RaspberryPi/portmacro.h	129;"	d
portYIELD_WITHIN_API	include/FreeRTOS.h	692;"	d
prvAddCoRoutineToReadyQueue	croutine.c	109;"	d	file:
prvAddCurrentTaskToDelayedList	tasks.c	/^static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )$/;"	f	file:
prvAddNewTaskToReadyList	tasks.c	/^static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )$/;"	f	file:
prvAddTaskToReadyList	tasks.c	259;"	d	file:
prvCheckDelayedList	croutine.c	/^static void prvCheckDelayedList( void )$/;"	f	file:
prvCheckForValidListAndQueue	timers.c	/^static void prvCheckForValidListAndQueue( void )$/;"	f	file:
prvCheckPendingReadyList	croutine.c	/^static void prvCheckPendingReadyList( void )$/;"	f	file:
prvCheckTasksWaitingTermination	tasks.c	/^static void prvCheckTasksWaitingTermination( void )$/;"	f	file:
prvCopyDataFromQueue	queue.c	/^static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )$/;"	f	file:
prvCopyDataToQueue	queue.c	/^static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )$/;"	f	file:
prvDeleteTCB	tasks.c	/^	static void prvDeleteTCB( TCB_t *pxTCB )$/;"	f	file:
prvGetExpectedIdleTime	tasks.c	/^	static TickType_t prvGetExpectedIdleTime( void )$/;"	f	file:
prvGetNextExpireTime	timers.c	/^static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )$/;"	f	file:
prvGetTCBFromHandle	tasks.c	272;"	d	file:
prvHeapInit	portable/MemMang/heap_2.c	/^static void prvHeapInit( void )$/;"	f	file:
prvHeapInit	portable/MemMang/heap_4.c	/^static void prvHeapInit( void )$/;"	f	file:
prvInitialiseCoRoutineLists	croutine.c	/^static void prvInitialiseCoRoutineLists( void )$/;"	f	file:
prvInitialiseMutex	queue.c	/^	static void prvInitialiseMutex( Queue_t *pxNewQueue )$/;"	f	file:
prvInitialiseNewQueue	queue.c	/^static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )$/;"	f	file:
prvInitialiseNewTask	tasks.c	/^static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,$/;"	f	file:
prvInitialiseNewTimer	timers.c	/^static void prvInitialiseNewTimer(	const char * const pcTimerName,$/;"	f	file:
prvInitialiseTaskLists	tasks.c	/^static void prvInitialiseTaskLists( void )$/;"	f	file:
prvInsertBlockIntoFreeList	portable/MemMang/heap_2.c	139;"	d	file:
prvInsertBlockIntoFreeList	portable/MemMang/heap_4.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )$/;"	f	file:
prvInsertBlockIntoFreeList	portable/MemMang/heap_5.c	/^static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )$/;"	f	file:
prvInsertTimerInActiveList	timers.c	/^static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )$/;"	f	file:
prvIsQueueEmpty	queue.c	/^static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )$/;"	f	file:
prvIsQueueFull	queue.c	/^static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )$/;"	f	file:
prvListTasksWithinSingleList	tasks.c	/^	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )$/;"	f	file:
prvLockQueue	queue.c	264;"	d	file:
prvNotifyQueueSetContainer	queue.c	/^	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )$/;"	f	file:
prvProcessExpiredTimer	timers.c	/^static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )$/;"	f	file:
prvProcessReceivedCommands	timers.c	/^static void	prvProcessReceivedCommands( void )$/;"	f	file:
prvProcessTimerOrBlockTask	timers.c	/^static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )$/;"	f	file:
prvResetNextTaskUnblockTime	tasks.c	/^static void prvResetNextTaskUnblockTime( void )$/;"	f	file:
prvSampleTimeNow	timers.c	/^static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )$/;"	f	file:
prvSearchForNameWithinSingleList	tasks.c	/^	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )$/;"	f	file:
prvSwitchTimerLists	timers.c	/^static void prvSwitchTimerLists( void )$/;"	f	file:
prvTaskCheckFreeStackSpace	tasks.c	/^	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )$/;"	f	file:
prvTaskExitError	portable/GCC/RaspberryPi/port.c	/^static void prvTaskExitError( void )$/;"	f	file:
prvTaskIsTaskSuspended	tasks.c	/^	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )$/;"	f	file:
prvTestWaitCondition	event_groups.c	/^static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )$/;"	f	file:
prvTimerTask	timers.c	/^static void prvTimerTask( void *pvParameters )$/;"	f	file:
prvUnlockQueue	queue.c	/^static void prvUnlockQueue( Queue_t * const pxQueue )$/;"	f	file:
prvWriteNameToBuffer	tasks.c	/^	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )$/;"	f	file:
pucStartAddress	include/portable.h	/^	uint8_t *pucStartAddress;$/;"	m	struct:HeapRegion
puxStackBuffer	include/task.h	/^	StackType_t *puxStackBuffer;$/;"	m	struct:xTASK_PARAMETERS
pvBaseAddress	include/task.h	/^	void *pvBaseAddress;$/;"	m	struct:xMEMORY_REGION
pvContainer	include/list.h	/^	void * configLIST_VOLATILE pvContainer;				\/*< Pointer to the list in which this list item is placed (if any). *\/$/;"	m	struct:xLIST_ITEM
pvDummy1	include/FreeRTOS.h	/^	void				*pvDummy1;$/;"	m	struct:xSTATIC_TIMER
pvDummy1	include/FreeRTOS.h	/^	void *pvDummy1[ 3 ];$/;"	m	struct:xSTATIC_QUEUE
pvDummy15	include/FreeRTOS.h	/^		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:xSTATIC_TCB
pvDummy2	include/FreeRTOS.h	/^		void *pvDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6
pvDummy2	include/FreeRTOS.h	/^	void *pvDummy2;$/;"	m	struct:xSTATIC_LIST
pvDummy2	include/FreeRTOS.h	/^	void *pvDummy2[ 2 ];$/;"	m	struct:xSTATIC_MINI_LIST_ITEM
pvDummy2	include/FreeRTOS.h	/^	void *pvDummy2[ 4 ];$/;"	m	struct:xSTATIC_LIST_ITEM
pvDummy5	include/FreeRTOS.h	/^	void 				*pvDummy5[ 2 ];$/;"	m	struct:xSTATIC_TIMER
pvDummy7	include/FreeRTOS.h	/^		void *pvDummy7;$/;"	m	struct:xSTATIC_QUEUE
pvOwner	include/list.h	/^	void * pvOwner;										\/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *\/$/;"	m	struct:xLIST_ITEM
pvParameter1	timers.c	/^	void *pvParameter1;						\/* << The value that will be used as the callback functions first parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
pvParameters	include/task.h	/^	void *pvParameters;$/;"	m	struct:xTASK_PARAMETERS
pvPortMalloc	portable/MemMang/heap_1.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMalloc	portable/MemMang/heap_2.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMalloc	portable/MemMang/heap_3.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMalloc	portable/MemMang/heap_4.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvPortMalloc	portable/MemMang/heap_5.c	/^void *pvPortMalloc( size_t xWantedSize )$/;"	f
pvTaskCode	include/task.h	/^	TaskFunction_t pvTaskCode;$/;"	m	struct:xTASK_PARAMETERS
pvTaskGetThreadLocalStoragePointer	include/mpu_wrappers.h	115;"	d
pvTaskGetThreadLocalStoragePointer	tasks.c	/^	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )$/;"	f
pvTaskIncrementMutexHeldCount	tasks.c	/^	void *pvTaskIncrementMutexHeldCount( void )$/;"	f
pvThreadLocalStoragePointers	tasks.c	/^		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];$/;"	m	struct:tskTaskControlBlock	file:
pvTimerGetTimerID	include/mpu_wrappers.h	161;"	d
pvTimerGetTimerID	timers.c	/^void *pvTimerGetTimerID( const TimerHandle_t xTimer )$/;"	f
pvTimerID	timers.c	/^	void 					*pvTimerID;			\/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. *\/$/;"	m	struct:tmrTimerControl	file:
pxCallbackFunction	timers.c	/^	PendedFunction_t	pxCallbackFunction;	\/* << The callback function to execute. *\/$/;"	m	struct:tmrCallbackParameters	file:
pxCallbackFunction	timers.c	/^	TimerCallbackFunction_t	pxCallbackFunction;	\/*<< The function that will be called when the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
pxCoRoutineFunction	include/croutine.h	/^	crCOROUTINE_CODE 	pxCoRoutineFunction;$/;"	m	struct:corCoRoutineControlBlock
pxCurrentCoRoutine	croutine.c	/^CRCB_t * pxCurrentCoRoutine = NULL;$/;"	v
pxCurrentTCB	tasks.c	/^PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;$/;"	v
pxCurrentTCBConst	portable/GCC/RaspberryPi/portASM.s	/^pxCurrentTCBConst: .word pxCurrentTCB$/;"	l
pxCurrentTimerList	timers.c	/^PRIVILEGED_DATA static List_t *pxCurrentTimerList;$/;"	v	file:
pxDelayedCoRoutineList	croutine.c	/^static List_t * pxDelayedCoRoutineList;									\/*< Points to the delayed co-routine list currently being used. *\/$/;"	v	file:
pxDelayedTaskList	tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				\/*< Points to the delayed task list currently being used. *\/$/;"	v	file:
pxDummy1	include/FreeRTOS.h	/^	void				*pxDummy1;$/;"	m	struct:xSTATIC_TCB
pxDummy14	include/FreeRTOS.h	/^		void			*pxDummy14;$/;"	m	struct:xSTATIC_TCB
pxDummy6	include/FreeRTOS.h	/^	void				*pxDummy6;$/;"	m	struct:xSTATIC_TCB
pxDummy8	include/FreeRTOS.h	/^		void			*pxDummy8;$/;"	m	struct:xSTATIC_TCB
pxEnd	portable/MemMang/heap_4.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
pxEnd	portable/MemMang/heap_5.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
pxEndOfStack	tasks.c	/^		StackType_t		*pxEndOfStack;		\/*< Points to the end of the stack on architectures where the stack grows up from low memory. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxISR	include/deprecated_definitions.h	/^	typedef void ( __interrupt __far *pxISR )();$/;"	t
pxISR	include/deprecated_definitions.h	/^    typedef void ( __interrupt __far *pxISR )();$/;"	t
pxIndex	include/list.h	/^	ListItem_t * configLIST_VOLATILE pxIndex;			\/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *\/$/;"	m	struct:xLIST
pxMutexHolder	queue.c	108;"	d	file:
pxNext	include/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		\/*< Pointer to the next ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxNext	include/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxNext;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxNextFreeBlock	portable/MemMang/heap_2.c	/^	struct A_BLOCK_LINK *pxNextFreeBlock;	\/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:
pxNextFreeBlock	portable/MemMang/heap_4.c	/^	struct A_BLOCK_LINK *pxNextFreeBlock;	\/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:
pxNextFreeBlock	portable/MemMang/heap_5.c	/^	struct A_BLOCK_LINK *pxNextFreeBlock;	\/*<< The next free block in the list. *\/$/;"	m	struct:A_BLOCK_LINK	typeref:struct:A_BLOCK_LINK::A_BLOCK_LINK	file:
pxOverflowDelayedCoRoutineList	croutine.c	/^static List_t * pxOverflowDelayedCoRoutineList;							\/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowDelayedTaskList	tasks.c	/^PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		\/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. *\/$/;"	v	file:
pxOverflowTimerList	timers.c	/^PRIVILEGED_DATA static List_t *pxOverflowTimerList;$/;"	v	file:
pxPortInitialiseStack	portable/GCC/RaspberryPi/port.c	/^StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )$/;"	f
pxPrevious	include/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	\/*< Pointer to the previous ListItem_t in the list. *\/$/;"	m	struct:xLIST_ITEM	typeref:struct:xLIST_ITEM::configLIST_VOLATILE
pxPrevious	include/list.h	/^	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;$/;"	m	struct:xMINI_LIST_ITEM	typeref:struct:xMINI_LIST_ITEM::configLIST_VOLATILE
pxQueueSetContainer	queue.c	/^		struct QueueDefinition *pxQueueSetContainer;$/;"	m	struct:QueueDefinition	typeref:struct:QueueDefinition::QueueDefinition	file:
pxReadyCoRoutineLists	croutine.c	/^static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	\/*< Prioritised ready co-routines. *\/$/;"	v	file:
pxReadyTasksLists	tasks.c	/^PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];\/*< Prioritised ready tasks. *\/$/;"	v	file:
pxStack	tasks.c	/^	StackType_t			*pxStack;			\/*< Points to the start of the stack. *\/$/;"	m	struct:tskTaskControlBlock	file:
pxStackBase	include/task.h	/^	StackType_t *pxStackBase;		\/* Points to the lowest address of the task's stack area. *\/$/;"	m	struct:xTASK_STATUS
pxTaskTag	tasks.c	/^		TaskHookFunction_t pxTaskTag;$/;"	m	struct:tskTaskControlBlock	file:
pxTimer	timers.c	/^	Timer_t *			pxTimer;			\/*<< The timer to which the command will be applied. *\/$/;"	m	struct:tmrTimerParameters	file:
pxTopOfStack	tasks.c	/^	volatile StackType_t	*pxTopOfStack;	\/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
queueLOCKED_UNMODIFIED	queue.c	95;"	d	file:
queueMUTEX_GIVE_BLOCK_TIME	queue.c	115;"	d	file:
queueOVERWRITE	include/queue.h	107;"	d
queueQUEUE_IS_MUTEX	queue.c	110;"	d	file:
queueQUEUE_TYPE_BASE	include/queue.h	110;"	d
queueQUEUE_TYPE_BINARY_SEMAPHORE	include/queue.h	114;"	d
queueQUEUE_TYPE_COUNTING_SEMAPHORE	include/queue.h	113;"	d
queueQUEUE_TYPE_MUTEX	include/queue.h	112;"	d
queueQUEUE_TYPE_RECURSIVE_MUTEX	include/queue.h	115;"	d
queueQUEUE_TYPE_SET	include/queue.h	111;"	d
queueSEMAPHORE_QUEUE_ITEM_LENGTH	queue.c	114;"	d	file:
queueSEND_TO_BACK	include/queue.h	105;"	d
queueSEND_TO_FRONT	include/queue.h	106;"	d
queueUNLOCKED	queue.c	94;"	d	file:
queueYIELD_IF_USING_PREEMPTION	queue.c	120;"	d	file:
queueYIELD_IF_USING_PREEMPTION	queue.c	122;"	d	file:
semBINARY_SEMAPHORE_QUEUE_LENGTH	include/semphr.h	81;"	d
semGIVE_BLOCK_TIME	include/semphr.h	83;"	d
semSEMAPHORE_QUEUE_ITEM_LENGTH	include/semphr.h	82;"	d
static	croutine.c	82;"	d	file:
static	tasks.c	153;"	d	file:
switch_before_exit	portable/GCC/RaspberryPi/portASM.s	/^switch_before_exit:$/;"	l
taskCHECK_FOR_STACK_OVERFLOW	include/StackMacros.h	107;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/StackMacros.h	122;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/StackMacros.h	141;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/StackMacros.h	165;"	d
taskCHECK_FOR_STACK_OVERFLOW	include/StackMacros.h	92;"	d
taskDISABLE_INTERRUPTS	include/task.h	242;"	d
taskENABLE_INTERRUPTS	include/task.h	252;"	d
taskENTER_CRITICAL	include/task.h	217;"	d
taskENTER_CRITICAL_FROM_ISR	include/task.h	218;"	d
taskEVENT_LIST_ITEM_VALUE_IN_USE	tasks.c	283;"	d	file:
taskEVENT_LIST_ITEM_VALUE_IN_USE	tasks.c	285;"	d	file:
taskEXIT_CRITICAL	include/task.h	232;"	d
taskEXIT_CRITICAL_FROM_ISR	include/task.h	233;"	d
taskNOTIFICATION_RECEIVED	tasks.c	112;"	d	file:
taskNOT_WAITING_NOTIFICATION	tasks.c	110;"	d	file:
taskRECORD_READY_PRIORITY	tasks.c	164;"	d	file:
taskRECORD_READY_PRIORITY	tasks.c	206;"	d	file:
taskRESET_READY_PRIORITY	tasks.c	196;"	d	file:
taskRESET_READY_PRIORITY	tasks.c	225;"	d	file:
taskSCHEDULER_NOT_STARTED	include/task.h	258;"	d
taskSCHEDULER_RUNNING	include/task.h	259;"	d
taskSCHEDULER_SUSPENDED	include/task.h	257;"	d
taskSELECT_HIGHEST_PRIORITY_TASK	tasks.c	174;"	d	file:
taskSELECT_HIGHEST_PRIORITY_TASK	tasks.c	210;"	d	file:
taskSWITCH_DELAYED_LISTS	tasks.c	239;"	d	file:
taskWAITING_NOTIFICATION	tasks.c	111;"	d	file:
taskYIELD	include/task.h	203;"	d
taskYIELD_IF_USING_PREEMPTION	tasks.c	104;"	d	file:
taskYIELD_IF_USING_PREEMPTION	tasks.c	106;"	d	file:
tmrCOMMAND_CHANGE_PERIOD	include/timers.h	102;"	d
tmrCOMMAND_CHANGE_PERIOD_FROM_ISR	include/timers.h	109;"	d
tmrCOMMAND_DELETE	include/timers.h	103;"	d
tmrCOMMAND_EXECUTE_CALLBACK	include/timers.h	97;"	d
tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR	include/timers.h	96;"	d
tmrCOMMAND_RESET	include/timers.h	100;"	d
tmrCOMMAND_RESET_FROM_ISR	include/timers.h	107;"	d
tmrCOMMAND_START	include/timers.h	99;"	d
tmrCOMMAND_START_DONT_TRACE	include/timers.h	98;"	d
tmrCOMMAND_START_FROM_ISR	include/timers.h	106;"	d
tmrCOMMAND_STOP	include/timers.h	101;"	d
tmrCOMMAND_STOP_FROM_ISR	include/timers.h	108;"	d
tmrCallbackParameters	timers.c	/^typedef struct tmrCallbackParameters$/;"	s	file:
tmrFIRST_FROM_ISR_COMMAND	include/timers.h	105;"	d
tmrNO_DELAY	timers.c	101;"	d	file:
tmrTIMER_CALLBACK	include/FreeRTOS.h	846;"	d
tmrTimerControl	timers.c	/^typedef struct tmrTimerControl$/;"	s	file:
tmrTimerParameters	timers.c	/^typedef struct tmrTimerParameters$/;"	s	file:
tmrTimerQueueMessage	timers.c	/^typedef struct tmrTimerQueueMessage$/;"	s	file:
traceBLOCKING_ON_QUEUE_RECEIVE	include/FreeRTOS.h	396;"	d
traceBLOCKING_ON_QUEUE_SEND	include/FreeRTOS.h	404;"	d
traceCREATE_COUNTING_SEMAPHORE	include/FreeRTOS.h	454;"	d
traceCREATE_COUNTING_SEMAPHORE_FAILED	include/FreeRTOS.h	458;"	d
traceCREATE_MUTEX	include/FreeRTOS.h	430;"	d
traceCREATE_MUTEX_FAILED	include/FreeRTOS.h	434;"	d
traceEND	include/FreeRTOS.h	343;"	d
traceEVENT_GROUP_CLEAR_BITS	include/FreeRTOS.h	602;"	d
traceEVENT_GROUP_CLEAR_BITS_FROM_ISR	include/FreeRTOS.h	606;"	d
traceEVENT_GROUP_CREATE	include/FreeRTOS.h	578;"	d
traceEVENT_GROUP_CREATE_FAILED	include/FreeRTOS.h	582;"	d
traceEVENT_GROUP_DELETE	include/FreeRTOS.h	618;"	d
traceEVENT_GROUP_SET_BITS	include/FreeRTOS.h	610;"	d
traceEVENT_GROUP_SET_BITS_FROM_ISR	include/FreeRTOS.h	614;"	d
traceEVENT_GROUP_SYNC_BLOCK	include/FreeRTOS.h	586;"	d
traceEVENT_GROUP_SYNC_END	include/FreeRTOS.h	590;"	d
traceEVENT_GROUP_WAIT_BITS_BLOCK	include/FreeRTOS.h	594;"	d
traceEVENT_GROUP_WAIT_BITS_END	include/FreeRTOS.h	598;"	d
traceFREE	include/FreeRTOS.h	574;"	d
traceGIVE_MUTEX_RECURSIVE	include/FreeRTOS.h	438;"	d
traceGIVE_MUTEX_RECURSIVE_FAILED	include/FreeRTOS.h	442;"	d
traceINCREASE_TICK_COUNT	include/FreeRTOS.h	355;"	d
traceLOW_POWER_IDLE_BEGIN	include/FreeRTOS.h	360;"	d
traceLOW_POWER_IDLE_END	include/FreeRTOS.h	365;"	d
traceMALLOC	include/FreeRTOS.h	570;"	d
traceMOVED_TASK_TO_READY_STATE	include/FreeRTOS.h	414;"	d
tracePEND_FUNC_CALL	include/FreeRTOS.h	622;"	d
tracePEND_FUNC_CALL_FROM_ISR	include/FreeRTOS.h	626;"	d
tracePOST_MOVED_TASK_TO_READY_STATE	include/FreeRTOS.h	418;"	d
traceQUEUE_CREATE	include/FreeRTOS.h	422;"	d
traceQUEUE_CREATE_FAILED	include/FreeRTOS.h	426;"	d
traceQUEUE_DELETE	include/FreeRTOS.h	506;"	d
traceQUEUE_PEEK	include/FreeRTOS.h	474;"	d
traceQUEUE_PEEK_FROM_ISR	include/FreeRTOS.h	478;"	d
traceQUEUE_PEEK_FROM_ISR_FAILED	include/FreeRTOS.h	502;"	d
traceQUEUE_RECEIVE	include/FreeRTOS.h	470;"	d
traceQUEUE_RECEIVE_FAILED	include/FreeRTOS.h	482;"	d
traceQUEUE_RECEIVE_FROM_ISR	include/FreeRTOS.h	494;"	d
traceQUEUE_RECEIVE_FROM_ISR_FAILED	include/FreeRTOS.h	498;"	d
traceQUEUE_REGISTRY_ADD	include/FreeRTOS.h	630;"	d
traceQUEUE_SEND	include/FreeRTOS.h	462;"	d
traceQUEUE_SEND_FAILED	include/FreeRTOS.h	466;"	d
traceQUEUE_SEND_FROM_ISR	include/FreeRTOS.h	486;"	d
traceQUEUE_SEND_FROM_ISR_FAILED	include/FreeRTOS.h	490;"	d
traceSTART	include/FreeRTOS.h	337;"	d
traceTAKE_MUTEX_RECURSIVE	include/FreeRTOS.h	446;"	d
traceTAKE_MUTEX_RECURSIVE_FAILED	include/FreeRTOS.h	450;"	d
traceTASK_CREATE	include/FreeRTOS.h	510;"	d
traceTASK_CREATE_FAILED	include/FreeRTOS.h	514;"	d
traceTASK_DELAY	include/FreeRTOS.h	526;"	d
traceTASK_DELAY_UNTIL	include/FreeRTOS.h	522;"	d
traceTASK_DELETE	include/FreeRTOS.h	518;"	d
traceTASK_INCREMENT_TICK	include/FreeRTOS.h	546;"	d
traceTASK_NOTIFY	include/FreeRTOS.h	650;"	d
traceTASK_NOTIFY_FROM_ISR	include/FreeRTOS.h	654;"	d
traceTASK_NOTIFY_GIVE_FROM_ISR	include/FreeRTOS.h	658;"	d
traceTASK_NOTIFY_TAKE	include/FreeRTOS.h	638;"	d
traceTASK_NOTIFY_TAKE_BLOCK	include/FreeRTOS.h	634;"	d
traceTASK_NOTIFY_WAIT	include/FreeRTOS.h	646;"	d
traceTASK_NOTIFY_WAIT_BLOCK	include/FreeRTOS.h	642;"	d
traceTASK_PRIORITY_DISINHERIT	include/FreeRTOS.h	388;"	d
traceTASK_PRIORITY_INHERIT	include/FreeRTOS.h	380;"	d
traceTASK_PRIORITY_SET	include/FreeRTOS.h	530;"	d
traceTASK_RESUME	include/FreeRTOS.h	538;"	d
traceTASK_RESUME_FROM_ISR	include/FreeRTOS.h	542;"	d
traceTASK_SUSPEND	include/FreeRTOS.h	534;"	d
traceTASK_SWITCHED_IN	include/FreeRTOS.h	349;"	d
traceTASK_SWITCHED_OUT	include/FreeRTOS.h	371;"	d
traceTIMER_COMMAND_RECEIVED	include/FreeRTOS.h	566;"	d
traceTIMER_COMMAND_SEND	include/FreeRTOS.h	558;"	d
traceTIMER_CREATE	include/FreeRTOS.h	550;"	d
traceTIMER_CREATE_FAILED	include/FreeRTOS.h	554;"	d
traceTIMER_EXPIRED	include/FreeRTOS.h	562;"	d
tskBLOCKED_CHAR	tasks.c	143;"	d	file:
tskDELETED_CHAR	tasks.c	145;"	d	file:
tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB	tasks.c	136;"	d	file:
tskIDLE_PRIORITY	include/task.h	193;"	d
tskKERNEL_VERSION_BUILD	include/task.h	91;"	d
tskKERNEL_VERSION_MAJOR	include/task.h	89;"	d
tskKERNEL_VERSION_MINOR	include/task.h	90;"	d
tskKERNEL_VERSION_NUMBER	include/task.h	88;"	d
tskREADY_CHAR	tasks.c	144;"	d	file:
tskSTACK_FILL_BYTE	tasks.c	118;"	d	file:
tskSTATICALLY_ALLOCATED_STACK_AND_TCB	tasks.c	138;"	d	file:
tskSTATICALLY_ALLOCATED_STACK_ONLY	tasks.c	137;"	d	file:
tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	tasks.c	135;"	d	file:
tskSUSPENDED_CHAR	tasks.c	146;"	d	file:
tskTCB	tasks.c	/^} tskTCB;$/;"	t	typeref:struct:tskTaskControlBlock	file:
tskTaskControlBlock	tasks.c	/^typedef struct tskTaskControlBlock$/;"	s	file:
u	include/FreeRTOS.h	/^	} u;$/;"	m	struct:xSTATIC_QUEUE	typeref:union:xSTATIC_QUEUE::__anon6
u	queue.c	/^	} u;$/;"	m	struct:QueueDefinition	typeref:union:QueueDefinition::__anon2	file:
u	timers.c	/^	} u;$/;"	m	struct:tmrTimerQueueMessage	typeref:union:tmrTimerQueueMessage::__anon1	file:
ucDelayAborted	tasks.c	/^		uint8_t ucDelayAborted;$/;"	m	struct:tskTaskControlBlock	file:
ucDummy19	include/FreeRTOS.h	/^		uint8_t 		ucDummy19;$/;"	m	struct:xSTATIC_TCB
ucDummy4	include/FreeRTOS.h	/^			uint8_t ucDummy4;$/;"	m	struct:xSTATIC_EVENT_GROUP
ucDummy5	include/FreeRTOS.h	/^	uint8_t ucDummy5[ 2 ];$/;"	m	struct:xSTATIC_QUEUE
ucDummy6	include/FreeRTOS.h	/^		uint8_t ucDummy6;$/;"	m	struct:xSTATIC_QUEUE
ucDummy7	include/FreeRTOS.h	/^		uint8_t 		ucDummy7;$/;"	m	struct:xSTATIC_TIMER
ucDummy7	include/FreeRTOS.h	/^	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];$/;"	m	struct:xSTATIC_TCB
ucDummy9	include/FreeRTOS.h	/^		uint8_t ucDummy9;$/;"	m	struct:xSTATIC_QUEUE
ucHeap	portable/MemMang/heap_1.c	/^	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucHeap	portable/MemMang/heap_2.c	/^	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucHeap	portable/MemMang/heap_4.c	/^	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];$/;"	v	file:
ucNotifyState	tasks.c	/^		volatile uint8_t ucNotifyState;$/;"	m	struct:tskTaskControlBlock	file:
ucQueueGetQueueType	queue.c	/^	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )$/;"	f
ucQueueType	queue.c	/^		uint8_t ucQueueType;$/;"	m	struct:QueueDefinition	file:
ucStaticallyAllocated	event_groups.c	/^		uint8_t ucStaticallyAllocated; \/*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:xEventGroupDefinition	file:
ucStaticallyAllocated	queue.c	/^		uint8_t ucStaticallyAllocated;	\/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:QueueDefinition	file:
ucStaticallyAllocated	tasks.c	/^		uint8_t	ucStaticallyAllocated; 		\/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. *\/$/;"	m	struct:tskTaskControlBlock	file:
ucStaticallyAllocated	timers.c	/^		uint8_t 			ucStaticallyAllocated; \/*<< Set to pdTRUE if the timer was created statically so no attempt is made to free the memory again if the timer is later deleted. *\/$/;"	m	struct:tmrTimerControl	file:
ulCriticalNesting	portable/GCC/RaspberryPi/port.c	/^volatile uint32_t ulCriticalNesting = 9999UL;$/;"	v
ulCriticalNestingConst	portable/GCC/RaspberryPi/portASM.s	/^ulCriticalNestingConst: .word ulCriticalNesting$/;"	l
ulDummy16	include/FreeRTOS.h	/^		uint32_t		ulDummy16;$/;"	m	struct:xSTATIC_TCB
ulDummy18	include/FreeRTOS.h	/^		uint32_t 		ulDummy18;$/;"	m	struct:xSTATIC_TCB
ulICCEOIR	portable/GCC/RaspberryPi/port.c	/^__attribute__(( used )) const uint32_t ulICCEOIR = configEOI_ADDRESS;$/;"	v
ulICCEOIRConst	portable/GCC/RaspberryPi/portASM.s	/^ulICCEOIRConst:	.word ulICCEOIR$/;"	l
ulLengthInBytes	include/task.h	/^	uint32_t ulLengthInBytes;$/;"	m	struct:xMEMORY_REGION
ulNotifiedValue	tasks.c	/^		volatile uint32_t ulNotifiedValue;$/;"	m	struct:tskTaskControlBlock	file:
ulParameter2	timers.c	/^	uint32_t ulParameter2;					\/* << The value that will be used as the callback functions second parameter. *\/$/;"	m	struct:tmrCallbackParameters	file:
ulParameters	include/task.h	/^	uint32_t ulParameters;$/;"	m	struct:xMEMORY_REGION
ulPortInterruptNesting	portable/GCC/RaspberryPi/port.c	/^volatile uint32_t ulPortInterruptNesting = 0UL;$/;"	v
ulPortInterruptNestingConst	portable/GCC/RaspberryPi/portASM.s	/^ulPortInterruptNestingConst: .word ulPortInterruptNesting$/;"	l
ulPortTaskHasFPUContext	portable/GCC/RaspberryPi/port.c	/^volatile uint32_t ulPortTaskHasFPUContext = pdFALSE;$/;"	v
ulPortTaskHasFPUContextConst	portable/GCC/RaspberryPi/portASM.s	/^ulPortTaskHasFPUContextConst: .word ulPortTaskHasFPUContext$/;"	l
ulPortYieldRequired	portable/GCC/RaspberryPi/port.c	/^volatile uint32_t ulPortYieldRequired = pdFALSE;$/;"	v
ulPortYieldRequiredConst	portable/GCC/RaspberryPi/portASM.s	/^ulPortYieldRequiredConst: .word ulPortYieldRequired$/;"	l
ulRunTimeCounter	include/task.h	/^	uint32_t ulRunTimeCounter;		\/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http:\/\/www.freertos.org\/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
ulRunTimeCounter	tasks.c	/^		uint32_t		ulRunTimeCounter;	\/*< Stores the amount of time the task has spent in the Running state. *\/$/;"	m	struct:tskTaskControlBlock	file:
ulTaskNotifyTake	include/mpu_wrappers.h	123;"	d
ulTaskNotifyTake	tasks.c	/^	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )$/;"	f
ulTaskSwitchedInTime	tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	\/*< Holds the value of a timer\/counter the last time a task was switched in. *\/$/;"	v	file:
ulTotalRunTime	tasks.c	/^	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		\/*< Holds the total amount of execution time as defined by the run time counter clock. *\/$/;"	v	file:
usStackDepth	include/task.h	/^	uint16_t usStackDepth;$/;"	m	struct:xTASK_PARAMETERS
usStackHighWaterMark	include/task.h	/^	uint16_t usStackHighWaterMark;	\/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. *\/$/;"	m	struct:xTASK_STATUS
uxAutoReload	timers.c	/^	UBaseType_t				uxAutoReload;		\/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. *\/$/;"	m	struct:tmrTimerControl	file:
uxBasePriority	include/task.h	/^	UBaseType_t uxBasePriority;		\/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. *\/$/;"	m	struct:xTASK_STATUS
uxBasePriority	tasks.c	/^		UBaseType_t		uxBasePriority;		\/*< The priority last assigned to the task - used by the priority inheritance mechanism. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCriticalNesting	tasks.c	/^		UBaseType_t		uxCriticalNesting;	\/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxCurrentNumberOfTasks	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;$/;"	v	file:
uxCurrentPriority	include/task.h	/^	UBaseType_t uxCurrentPriority;	\/* The priority at which the task was running (may be inherited) when the structure was populated. *\/$/;"	m	struct:xTASK_STATUS
uxDeletedTasksWaitingCleanUp	tasks.c	/^	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;$/;"	v	file:
uxDummy1	include/FreeRTOS.h	/^	UBaseType_t uxDummy1;$/;"	m	struct:xSTATIC_LIST
uxDummy10	include/FreeRTOS.h	/^		UBaseType_t		uxDummy10[ 2 ];$/;"	m	struct:xSTATIC_TCB
uxDummy12	include/FreeRTOS.h	/^		UBaseType_t		uxDummy12[ 2 ];$/;"	m	struct:xSTATIC_TCB
uxDummy2	include/FreeRTOS.h	/^		UBaseType_t uxDummy2;$/;"	m	union:xSTATIC_QUEUE::__anon6
uxDummy20	include/FreeRTOS.h	/^		uint8_t			uxDummy20;$/;"	m	struct:xSTATIC_TCB
uxDummy3	include/FreeRTOS.h	/^		UBaseType_t uxDummy3;$/;"	m	struct:xSTATIC_EVENT_GROUP
uxDummy4	include/FreeRTOS.h	/^	UBaseType_t			uxDummy4;$/;"	m	struct:xSTATIC_TIMER
uxDummy4	include/FreeRTOS.h	/^	UBaseType_t uxDummy4[ 3 ];$/;"	m	struct:xSTATIC_QUEUE
uxDummy5	include/FreeRTOS.h	/^	UBaseType_t			uxDummy5;$/;"	m	struct:xSTATIC_TCB
uxDummy6	include/FreeRTOS.h	/^		UBaseType_t		uxDummy6;$/;"	m	struct:xSTATIC_TIMER
uxDummy8	include/FreeRTOS.h	/^		UBaseType_t uxDummy8;$/;"	m	struct:xSTATIC_QUEUE
uxDummy9	include/FreeRTOS.h	/^		UBaseType_t		uxDummy9;$/;"	m	struct:xSTATIC_TCB
uxEventBits	event_groups.c	/^	EventBits_t uxEventBits;$/;"	m	struct:xEventGroupDefinition	file:
uxEventGroupGetNumber	event_groups.c	/^	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )$/;"	f
uxEventGroupNumber	event_groups.c	/^		UBaseType_t uxEventGroupNumber;$/;"	m	struct:xEventGroupDefinition	file:
uxIndex	include/croutine.h	/^	UBaseType_t 		uxIndex;			\/*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *\/$/;"	m	struct:corCoRoutineControlBlock
uxItemSize	queue.c	/^	UBaseType_t uxItemSize;			\/*< The size of each items that the queue will hold. *\/$/;"	m	struct:QueueDefinition	file:
uxLength	queue.c	/^	UBaseType_t uxLength;			\/*< The length of the queue defined as the number of items it will hold, not the number of bytes. *\/$/;"	m	struct:QueueDefinition	file:
uxListRemove	list.c	/^UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )$/;"	f
uxMessagesWaiting	queue.c	/^	volatile UBaseType_t uxMessagesWaiting;\/*< The number of items currently in the queue. *\/$/;"	m	struct:QueueDefinition	file:
uxMutexesHeld	tasks.c	/^		UBaseType_t		uxMutexesHeld;$/;"	m	struct:tskTaskControlBlock	file:
uxNumberOfItems	include/list.h	/^	configLIST_VOLATILE UBaseType_t uxNumberOfItems;$/;"	m	struct:xLIST
uxPendedTicks	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;$/;"	v	file:
uxPriority	include/croutine.h	/^	UBaseType_t 		uxPriority;			\/*< The priority of the co-routine in relation to other co-routines. *\/$/;"	m	struct:corCoRoutineControlBlock
uxPriority	include/task.h	/^	UBaseType_t uxPriority;$/;"	m	struct:xTASK_PARAMETERS
uxPriority	tasks.c	/^	UBaseType_t			uxPriority;			\/*< The priority of the task.  0 is the lowest priority. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxQueueGetQueueNumber	queue.c	/^	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaiting	include/mpu_wrappers.h	134;"	d
uxQueueMessagesWaiting	queue.c	/^UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )$/;"	f
uxQueueMessagesWaitingFromISR	queue.c	/^UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )$/;"	f
uxQueueNumber	queue.c	/^		UBaseType_t uxQueueNumber;$/;"	m	struct:QueueDefinition	file:
uxQueueSpacesAvailable	include/mpu_wrappers.h	135;"	d
uxQueueSpacesAvailable	queue.c	/^UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )$/;"	f
uxQueueType	queue.c	109;"	d	file:
uxRecursiveCallCount	queue.c	/^		UBaseType_t uxRecursiveCallCount;\/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. *\/$/;"	m	union:QueueDefinition::__anon2	file:
uxSchedulerSuspended	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;$/;"	v	file:
uxSemaphoreGetCount	include/semphr.h	1167;"	d
uxState	include/croutine.h	/^	uint16_t 			uxState;			\/*< Used internally by the co-routine implementation. *\/$/;"	m	struct:corCoRoutineControlBlock
uxTCBNumber	tasks.c	/^		UBaseType_t		uxTCBNumber;		\/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskGetNumberOfTasks	include/mpu_wrappers.h	108;"	d
uxTaskGetNumberOfTasks	tasks.c	/^UBaseType_t uxTaskGetNumberOfTasks( void )$/;"	f
uxTaskGetStackHighWaterMark	include/mpu_wrappers.h	111;"	d
uxTaskGetStackHighWaterMark	tasks.c	/^	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )$/;"	f
uxTaskGetSystemState	include/mpu_wrappers.h	118;"	d
uxTaskGetSystemState	tasks.c	/^	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )$/;"	f
uxTaskGetTaskNumber	tasks.c	/^	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )$/;"	f
uxTaskNumber	tasks.c	/^		UBaseType_t		uxTaskNumber;		\/*< Stores a number specifically for use by third party trace code. *\/$/;"	m	struct:tskTaskControlBlock	file:
uxTaskNumber	tasks.c	/^PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;$/;"	v	file:
uxTaskPriorityGet	include/mpu_wrappers.h	99;"	d
uxTaskPriorityGet	tasks.c	/^	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )$/;"	f
uxTaskPriorityGetFromISR	tasks.c	/^	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )$/;"	f
uxTaskResetEventItemValue	tasks.c	/^TickType_t uxTaskResetEventItemValue( void )$/;"	f
uxTimerNumber	timers.c	/^		UBaseType_t			uxTimerNumber;		\/*<< An ID assigned by trace tools such as FreeRTOS+Trace *\/$/;"	m	struct:tmrTimerControl	file:
uxTopCoRoutineReadyPriority	croutine.c	/^static UBaseType_t uxTopCoRoutineReadyPriority = 0;$/;"	v	file:
uxTopReadyPriority	tasks.c	/^PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;$/;"	v	file:
vApplicationIRQHandlerConst	portable/GCC/RaspberryPi/portASM.s	/^vApplicationIRQHandlerConst: .word vApplicationIRQHandler$/;"	l
vClearTimerInterrupt	portable/GCC/RaspberryPi/portISR.c	/^void vClearTimerInterrupt( void )$/;"	f
vCoRoutineAddToDelayedList	croutine.c	/^void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )$/;"	f
vCoRoutineSchedule	croutine.c	/^void vCoRoutineSchedule( void )$/;"	f
vEventGroupClearBitsCallback	event_groups.c	/^void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )$/;"	f
vEventGroupDelete	event_groups.c	/^void vEventGroupDelete( EventGroupHandle_t xEventGroup )$/;"	f
vEventGroupDelete	include/mpu_wrappers.h	178;"	d
vEventGroupSetBitsCallback	event_groups.c	/^void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )$/;"	f
vListInitialise	list.c	/^void vListInitialise( List_t * const pxList )$/;"	f
vListInitialiseItem	list.c	/^void vListInitialiseItem( ListItem_t * const pxItem )$/;"	f
vListInsert	list.c	/^void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vListInsertEnd	list.c	/^void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )$/;"	f
vPortDefineHeapRegions	portable/MemMang/heap_5.c	/^void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )$/;"	f
vPortEndScheduler	portable/GCC/RaspberryPi/port.c	/^void vPortEndScheduler( void )$/;"	f
vPortEnterCritical	portable/GCC/RaspberryPi/port.c	/^void vPortEnterCritical( void )$/;"	f
vPortExitCritical	portable/GCC/RaspberryPi/port.c	/^void vPortExitCritical( void )$/;"	f
vPortFree	portable/MemMang/heap_1.c	/^void vPortFree( void *pv )$/;"	f
vPortFree	portable/MemMang/heap_2.c	/^void vPortFree( void *pv )$/;"	f
vPortFree	portable/MemMang/heap_3.c	/^void vPortFree( void *pv )$/;"	f
vPortFree	portable/MemMang/heap_4.c	/^void vPortFree( void *pv )$/;"	f
vPortFree	portable/MemMang/heap_5.c	/^void vPortFree( void *pv )$/;"	f
vPortInitialiseBlocks	portable/MemMang/heap_1.c	/^void vPortInitialiseBlocks( void )$/;"	f
vPortInitialiseBlocks	portable/MemMang/heap_2.c	/^void vPortInitialiseBlocks( void )$/;"	f
vPortInitialiseBlocks	portable/MemMang/heap_4.c	/^void vPortInitialiseBlocks( void )$/;"	f
vPortRestoreTaskContext	portable/GCC/RaspberryPi/portASM.s	/^vPortRestoreTaskContext:$/;"	l
vPortTaskUsesFPU	portable/GCC/RaspberryPi/port.c	/^void vPortTaskUsesFPU( void )$/;"	f
vQueueAddToRegistry	include/FreeRTOS.h	324;"	d
vQueueAddToRegistry	include/mpu_wrappers.h	153;"	d
vQueueAddToRegistry	queue.c	/^	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
vQueueDelete	include/mpu_wrappers.h	136;"	d
vQueueDelete	queue.c	/^void vQueueDelete( QueueHandle_t xQueue )$/;"	f
vQueueSetQueueNumber	queue.c	/^	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )$/;"	f
vQueueUnregisterQueue	include/FreeRTOS.h	325;"	d
vQueueUnregisterQueue	include/mpu_wrappers.h	154;"	d
vQueueUnregisterQueue	queue.c	/^	void vQueueUnregisterQueue( QueueHandle_t xQueue )$/;"	f
vQueueWaitForMessageRestricted	queue.c	/^	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )$/;"	f
vSemaphoreCreateBinary	include/semphr.h	136;"	d
vSemaphoreDelete	include/semphr.h	1140;"	d
vSetupTimerInterrupt	portable/GCC/RaspberryPi/portISR.c	/^void vSetupTimerInterrupt( void )$/;"	f
vTaskAllocateMPURegions	include/mpu_wrappers.h	94;"	d
vTaskAllocateMPURegions	tasks.c	/^	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )$/;"	f
vTaskDelay	include/mpu_wrappers.h	96;"	d
vTaskDelay	tasks.c	/^	void vTaskDelay( const TickType_t xTicksToDelay )$/;"	f
vTaskDelayUntil	include/mpu_wrappers.h	97;"	d
vTaskDelayUntil	tasks.c	/^	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )$/;"	f
vTaskDelete	include/mpu_wrappers.h	95;"	d
vTaskDelete	tasks.c	/^	void vTaskDelete( TaskHandle_t xTaskToDelete )$/;"	f
vTaskEndScheduler	tasks.c	/^void vTaskEndScheduler( void )$/;"	f
vTaskEnterCritical	tasks.c	/^	void vTaskEnterCritical( void )$/;"	f
vTaskExitCritical	tasks.c	/^	void vTaskExitCritical( void )$/;"	f
vTaskGetInfo	include/mpu_wrappers.h	101;"	d
vTaskGetInfo	tasks.c	/^	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )$/;"	f
vTaskGetRunTimeStats	include/mpu_wrappers.h	120;"	d
vTaskGetRunTimeStats	tasks.c	/^	void vTaskGetRunTimeStats( char *pcWriteBuffer )$/;"	f
vTaskGetTaskInfo	include/FreeRTOS.h	842;"	d
vTaskList	include/mpu_wrappers.h	119;"	d
vTaskList	tasks.c	/^	void vTaskList( char * pcWriteBuffer )$/;"	f
vTaskMissedYield	tasks.c	/^void vTaskMissedYield( void )$/;"	f
vTaskNotifyGiveFromISR	tasks.c	/^	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
vTaskPlaceOnEventList	tasks.c	/^void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )$/;"	f
vTaskPlaceOnEventListRestricted	tasks.c	/^	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )$/;"	f
vTaskPlaceOnUnorderedEventList	tasks.c	/^void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )$/;"	f
vTaskPriorityInherit	tasks.c	/^	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )$/;"	f
vTaskPrioritySet	include/mpu_wrappers.h	102;"	d
vTaskPrioritySet	tasks.c	/^	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )$/;"	f
vTaskResume	include/mpu_wrappers.h	104;"	d
vTaskResume	tasks.c	/^	void vTaskResume( TaskHandle_t xTaskToResume )$/;"	f
vTaskSetApplicationTaskTag	include/mpu_wrappers.h	112;"	d
vTaskSetApplicationTaskTag	tasks.c	/^	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )$/;"	f
vTaskSetTaskNumber	tasks.c	/^	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )$/;"	f
vTaskSetThreadLocalStoragePointer	include/mpu_wrappers.h	114;"	d
vTaskSetThreadLocalStoragePointer	tasks.c	/^	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )$/;"	f
vTaskSetTimeOutState	include/mpu_wrappers.h	127;"	d
vTaskSetTimeOutState	tasks.c	/^void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )$/;"	f
vTaskStartScheduler	tasks.c	/^void vTaskStartScheduler( void )$/;"	f
vTaskStepTick	tasks.c	/^	void vTaskStepTick( const TickType_t xTicksToJump )$/;"	f
vTaskSuspend	include/mpu_wrappers.h	103;"	d
vTaskSuspend	tasks.c	/^	void vTaskSuspend( TaskHandle_t xTaskToSuspend )$/;"	f
vTaskSuspendAll	include/mpu_wrappers.h	105;"	d
vTaskSuspendAll	tasks.c	/^void vTaskSuspendAll( void )$/;"	f
vTaskSwitchContext	tasks.c	/^void vTaskSwitchContext( void )$/;"	f
vTaskSwitchContextConst	portable/GCC/RaspberryPi/portASM.s	/^vTaskSwitchContextConst: .word vTaskSwitchContext$/;"	l
vTimerSetTimerID	include/mpu_wrappers.h	162;"	d
vTimerSetTimerID	timers.c	/^void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )$/;"	f
xActiveTimerList1	timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList1;$/;"	v	file:
xActiveTimerList2	timers.c	/^PRIVILEGED_DATA static List_t xActiveTimerList2;$/;"	v	file:
xBlockAllocatedBit	portable/MemMang/heap_4.c	/^static size_t xBlockAllocatedBit = 0;$/;"	v	file:
xBlockAllocatedBit	portable/MemMang/heap_5.c	/^static size_t xBlockAllocatedBit = 0;$/;"	v	file:
xBlockSize	portable/MemMang/heap_2.c	/^	size_t xBlockSize;						\/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:
xBlockSize	portable/MemMang/heap_4.c	/^	size_t xBlockSize;						\/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:
xBlockSize	portable/MemMang/heap_5.c	/^	size_t xBlockSize;						\/*<< The size of the free block. *\/$/;"	m	struct:A_BLOCK_LINK	file:
xCallbackParameters	timers.c	/^			CallbackParameters_t xCallbackParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:
xCoRoutineCreate	croutine.c	/^BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )$/;"	f
xCoRoutineHandle	include/FreeRTOS.h	836;"	d
xCoRoutineRemoveFromEventList	croutine.c	/^BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )$/;"	f
xCoRoutineTickCount	croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xDelayedCoRoutineList1	croutine.c	/^static List_t xDelayedCoRoutineList1;									\/*< Delayed co-routines. *\/$/;"	v	file:
xDelayedCoRoutineList2	croutine.c	/^static List_t xDelayedCoRoutineList2;									\/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDelayedTaskList1	tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList1;						\/*< Delayed tasks. *\/$/;"	v	file:
xDelayedTaskList2	tasks.c	/^PRIVILEGED_DATA static List_t xDelayedTaskList2;						\/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. *\/$/;"	v	file:
xDummy1	include/FreeRTOS.h	/^	TickType_t xDummy1;$/;"	m	struct:xSTATIC_EVENT_GROUP
xDummy1	include/FreeRTOS.h	/^	TickType_t xDummy1;$/;"	m	struct:xSTATIC_LIST_ITEM
xDummy1	include/FreeRTOS.h	/^	TickType_t xDummy1;$/;"	m	struct:xSTATIC_MINI_LIST_ITEM
xDummy17	include/FreeRTOS.h	/^		struct	_reent	xDummy17;$/;"	m	struct:xSTATIC_TCB	typeref:struct:xSTATIC_TCB::_reent
xDummy2	include/FreeRTOS.h	/^		xMPU_SETTINGS	xDummy2;$/;"	m	struct:xSTATIC_TCB
xDummy2	include/FreeRTOS.h	/^	StaticListItem_t	xDummy2;$/;"	m	struct:xSTATIC_TIMER
xDummy2	include/FreeRTOS.h	/^	StaticList_t xDummy2;$/;"	m	struct:xSTATIC_EVENT_GROUP
xDummy3	include/FreeRTOS.h	/^	StaticListItem_t	xDummy3[ 2 ];$/;"	m	struct:xSTATIC_TCB
xDummy3	include/FreeRTOS.h	/^	StaticList_t xDummy3[ 2 ];$/;"	m	struct:xSTATIC_QUEUE
xDummy3	include/FreeRTOS.h	/^	StaticMiniListItem_t xDummy3;$/;"	m	struct:xSTATIC_LIST
xDummy3	include/FreeRTOS.h	/^	TickType_t			xDummy3;$/;"	m	struct:xSTATIC_TIMER
xEnd	portable/MemMang/heap_2.c	/^static BlockLink_t xStart, xEnd;$/;"	v	file:
xEventGroupClearBits	event_groups.c	/^EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupClearBits	include/mpu_wrappers.h	175;"	d
xEventGroupClearBitsFromISR	event_groups.c	/^	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )$/;"	f
xEventGroupClearBitsFromISR	include/event_groups.h	451;"	d
xEventGroupCreate	event_groups.c	/^	EventGroupHandle_t xEventGroupCreate( void )$/;"	f
xEventGroupCreate	include/mpu_wrappers.h	172;"	d
xEventGroupCreateStatic	event_groups.c	/^	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )$/;"	f
xEventGroupCreateStatic	include/mpu_wrappers.h	173;"	d
xEventGroupDefinition	event_groups.c	/^typedef struct xEventGroupDefinition$/;"	s	file:
xEventGroupGetBits	include/event_groups.h	749;"	d
xEventGroupGetBitsFromISR	event_groups.c	/^EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )$/;"	f
xEventGroupSetBits	event_groups.c	/^EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )$/;"	f
xEventGroupSetBits	include/mpu_wrappers.h	176;"	d
xEventGroupSetBitsFromISR	event_groups.c	/^	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xEventGroupSetBitsFromISR	include/event_groups.h	603;"	d
xEventGroupSync	event_groups.c	/^EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )$/;"	f
xEventGroupSync	include/mpu_wrappers.h	177;"	d
xEventGroupWaitBits	event_groups.c	/^EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )$/;"	f
xEventGroupWaitBits	include/mpu_wrappers.h	174;"	d
xEventListItem	include/croutine.h	/^	ListItem_t			xEventListItem;		\/*< List item used to place the CRCB in event lists. *\/$/;"	m	struct:corCoRoutineControlBlock
xEventListItem	tasks.c	/^	ListItem_t			xEventListItem;		\/*< Used to reference a task from an event list. *\/$/;"	m	struct:tskTaskControlBlock	file:
xFreeBytesRemaining	portable/MemMang/heap_2.c	/^static size_t xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;$/;"	v	file:
xFreeBytesRemaining	portable/MemMang/heap_4.c	/^static size_t xFreeBytesRemaining = 0U;$/;"	v	file:
xFreeBytesRemaining	portable/MemMang/heap_5.c	/^static size_t xFreeBytesRemaining = 0U;$/;"	v	file:
xGenericListItem	include/croutine.h	/^	ListItem_t			xGenericListItem;	\/*< List item used to place the CRCB in ready and blocked queues. *\/$/;"	m	struct:corCoRoutineControlBlock
xHandle	include/task.h	/^	TaskHandle_t xHandle;			\/* The handle of the task to which the rest of the information in the structure relates. *\/$/;"	m	struct:xTASK_STATUS
xHandle	queue.c	/^		QueueHandle_t xHandle;$/;"	m	struct:QUEUE_REGISTRY_ITEM	file:
xHeapStructSize	portable/MemMang/heap_4.c	/^static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xHeapStructSize	portable/MemMang/heap_5.c	/^static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );$/;"	v	file:
xIdleTaskHandle	tasks.c	/^PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			\/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. *\/$/;"	v	file:
xItemValue	include/list.h	/^	configLIST_VOLATILE TickType_t xItemValue;			\/*< The value being listed.  In most cases this is used to sort the list in descending order. *\/$/;"	m	struct:xLIST_ITEM
xItemValue	include/list.h	/^	configLIST_VOLATILE TickType_t xItemValue;$/;"	m	struct:xMINI_LIST_ITEM
xLIST	include/list.h	/^typedef struct xLIST$/;"	s
xLIST_ITEM	include/list.h	/^struct xLIST_ITEM$/;"	s
xLastTickCount	croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xList	include/FreeRTOS.h	849;"	d
xListEnd	include/list.h	/^	MiniListItem_t xListEnd;							\/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *\/$/;"	m	struct:xLIST
xListItem	include/FreeRTOS.h	848;"	d
xMEMORY_REGION	include/task.h	/^typedef struct xMEMORY_REGION$/;"	s
xMINI_LIST_ITEM	include/list.h	/^struct xMINI_LIST_ITEM$/;"	s
xMPUSettings	tasks.c	/^		xMPU_SETTINGS	xMPUSettings;		\/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. *\/$/;"	m	struct:tskTaskControlBlock	file:
xMemoryRegion	include/FreeRTOS.h	832;"	d
xMessageID	timers.c	/^	BaseType_t			xMessageID;			\/*<< The command being sent to the timer service task. *\/$/;"	m	struct:tmrTimerQueueMessage	file:
xMessageValue	timers.c	/^	TickType_t			xMessageValue;		\/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. *\/$/;"	m	struct:tmrTimerParameters	file:
xMinimumEverFreeBytesRemaining	portable/MemMang/heap_4.c	/^static size_t xMinimumEverFreeBytesRemaining = 0U;$/;"	v	file:
xMinimumEverFreeBytesRemaining	portable/MemMang/heap_5.c	/^static size_t xMinimumEverFreeBytesRemaining = 0U;$/;"	v	file:
xNewLib_reent	tasks.c	/^		struct	_reent xNewLib_reent;$/;"	m	struct:tskTaskControlBlock	typeref:struct:tskTaskControlBlock::_reent	file:
xNextFreeByte	portable/MemMang/heap_1.c	/^static size_t xNextFreeByte = ( size_t ) 0;$/;"	v	file:
xNextTaskUnblockTime	tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; \/* Initialised to portMAX_DELAY before the scheduler starts. *\/$/;"	v	file:
xNumOfOverflows	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;$/;"	v	file:
xOverflowCount	include/task.h	/^	BaseType_t xOverflowCount;$/;"	m	struct:xTIME_OUT
xPassedTicks	croutine.c	/^static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;$/;"	v	file:
xPendingReadyCoRoutineList	croutine.c	/^static List_t xPendingReadyCoRoutineList;								\/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. *\/$/;"	v	file:
xPendingReadyList	tasks.c	/^PRIVILEGED_DATA static List_t xPendingReadyList;						\/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. *\/$/;"	v	file:
xPortGetFreeHeapSize	portable/MemMang/heap_1.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f
xPortGetFreeHeapSize	portable/MemMang/heap_2.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f
xPortGetFreeHeapSize	portable/MemMang/heap_4.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f
xPortGetFreeHeapSize	portable/MemMang/heap_5.c	/^size_t xPortGetFreeHeapSize( void )$/;"	f
xPortGetMinimumEverFreeHeapSize	portable/MemMang/heap_4.c	/^size_t xPortGetMinimumEverFreeHeapSize( void )$/;"	f
xPortGetMinimumEverFreeHeapSize	portable/MemMang/heap_5.c	/^size_t xPortGetMinimumEverFreeHeapSize( void )$/;"	f
xPortStartScheduler	portable/GCC/RaspberryPi/port.c	/^BaseType_t xPortStartScheduler( void )$/;"	f
xQUEUE	queue.c	/^} xQUEUE;$/;"	t	typeref:struct:QueueDefinition	file:
xQueueAddToSet	include/mpu_wrappers.h	147;"	d
xQueueAddToSet	queue.c	/^	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueCRReceive	queue.c	/^	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )$/;"	f
xQueueCRReceiveFromISR	queue.c	/^	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )$/;"	f
xQueueCRSend	queue.c	/^	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )$/;"	f
xQueueCRSendFromISR	queue.c	/^	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )$/;"	f
xQueueCreate	include/queue.h	186;"	d
xQueueCreateCountingSemaphore	include/mpu_wrappers.h	139;"	d
xQueueCreateCountingSemaphore	queue.c	/^	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )$/;"	f
xQueueCreateCountingSemaphoreStatic	include/mpu_wrappers.h	140;"	d
xQueueCreateCountingSemaphoreStatic	queue.c	/^	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )$/;"	f
xQueueCreateMutex	include/mpu_wrappers.h	137;"	d
xQueueCreateMutex	queue.c	/^	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )$/;"	f
xQueueCreateMutexStatic	include/mpu_wrappers.h	138;"	d
xQueueCreateMutexStatic	queue.c	/^	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )$/;"	f
xQueueCreateSet	include/mpu_wrappers.h	146;"	d
xQueueCreateSet	queue.c	/^	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )$/;"	f
xQueueCreateStatic	include/queue.h	272;"	d
xQueueGenericCreate	include/mpu_wrappers.h	144;"	d
xQueueGenericCreate	queue.c	/^	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )$/;"	f
xQueueGenericCreateStatic	include/mpu_wrappers.h	145;"	d
xQueueGenericCreateStatic	queue.c	/^	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )$/;"	f
xQueueGenericReceive	include/mpu_wrappers.h	133;"	d
xQueueGenericReceive	queue.c	/^BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )$/;"	f
xQueueGenericReset	include/mpu_wrappers.h	150;"	d
xQueueGenericReset	queue.c	/^BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )$/;"	f
xQueueGenericSend	include/mpu_wrappers.h	132;"	d
xQueueGenericSend	queue.c	/^BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )$/;"	f
xQueueGenericSendFromISR	queue.c	/^BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )$/;"	f
xQueueGetMutexHolder	include/mpu_wrappers.h	141;"	d
xQueueGetMutexHolder	queue.c	/^	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )$/;"	f
xQueueGiveFromISR	queue.c	/^BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )$/;"	f
xQueueGiveMutexRecursive	include/mpu_wrappers.h	143;"	d
xQueueGiveMutexRecursive	queue.c	/^	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )$/;"	f
xQueueHandle	include/FreeRTOS.h	827;"	d
xQueueIsQueueEmptyFromISR	queue.c	/^BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueIsQueueFullFromISR	queue.c	/^BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )$/;"	f
xQueueOverwrite	include/queue.h	604;"	d
xQueueOverwriteFromISR	include/queue.h	1287;"	d
xQueuePeek	include/queue.h	788;"	d
xQueuePeekFromISR	queue.c	/^BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )$/;"	f
xQueueReceive	include/queue.h	914;"	d
xQueueReceiveFromISR	queue.c	/^BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )$/;"	f
xQueueRegistry	queue.c	/^	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];$/;"	v
xQueueRegistryItem	queue.c	/^	} xQueueRegistryItem;$/;"	t	typeref:struct:QUEUE_REGISTRY_ITEM	file:
xQueueRemoveFromSet	include/mpu_wrappers.h	148;"	d
xQueueRemoveFromSet	queue.c	/^	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )$/;"	f
xQueueReset	include/queue.h	1576;"	d
xQueueSelectFromSet	include/mpu_wrappers.h	149;"	d
xQueueSelectFromSet	queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )$/;"	f
xQueueSelectFromSetFromISR	queue.c	/^	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )$/;"	f
xQueueSend	include/queue.h	521;"	d
xQueueSendFromISR	include/queue.h	1361;"	d
xQueueSendToBack	include/queue.h	437;"	d
xQueueSendToBackFromISR	include/queue.h	1200;"	d
xQueueSendToFront	include/queue.h	355;"	d
xQueueSendToFrontFromISR	include/queue.h	1129;"	d
xQueueSetHandle	include/FreeRTOS.h	829;"	d
xQueueSetMemberHandle	include/FreeRTOS.h	830;"	d
xQueueTakeMutexRecursive	include/mpu_wrappers.h	142;"	d
xQueueTakeMutexRecursive	queue.c	/^	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )$/;"	f
xRegions	include/task.h	/^	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];$/;"	m	struct:xTASK_PARAMETERS
xSTATIC_EVENT_GROUP	include/FreeRTOS.h	/^typedef struct xSTATIC_EVENT_GROUP$/;"	s
xSTATIC_LIST	include/FreeRTOS.h	/^typedef struct xSTATIC_LIST$/;"	s
xSTATIC_LIST_ITEM	include/FreeRTOS.h	/^struct xSTATIC_LIST_ITEM$/;"	s
xSTATIC_MINI_LIST_ITEM	include/FreeRTOS.h	/^struct xSTATIC_MINI_LIST_ITEM$/;"	s
xSTATIC_QUEUE	include/FreeRTOS.h	/^typedef struct xSTATIC_QUEUE$/;"	s
xSTATIC_TCB	include/FreeRTOS.h	/^typedef struct xSTATIC_TCB$/;"	s
xSTATIC_TIMER	include/FreeRTOS.h	/^typedef struct xSTATIC_TIMER$/;"	s
xSchedulerRunning	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;$/;"	v	file:
xSemaphoreCreateBinary	include/semphr.h	204;"	d
xSemaphoreCreateBinaryStatic	include/semphr.h	263;"	d
xSemaphoreCreateCounting	include/semphr.h	1040;"	d
xSemaphoreCreateCountingStatic	include/semphr.h	1125;"	d
xSemaphoreCreateMutex	include/semphr.h	758;"	d
xSemaphoreCreateMutexStatic	include/semphr.h	819;"	d
xSemaphoreCreateRecursiveMutex	include/semphr.h	887;"	d
xSemaphoreCreateRecursiveMutexStatic	include/semphr.h	960;"	d
xSemaphoreGetMutexHolder	include/semphr.h	1155;"	d
xSemaphoreGive	include/semphr.h	489;"	d
xSemaphoreGiveFromISR	include/semphr.h	666;"	d
xSemaphoreGiveRecursive	include/semphr.h	574;"	d
xSemaphoreHandle	include/FreeRTOS.h	828;"	d
xSemaphoreTake	include/semphr.h	331;"	d
xSemaphoreTakeFromISR	include/semphr.h	700;"	d
xSemaphoreTakeRecursive	include/semphr.h	425;"	d
xSizeInBytes	include/portable.h	/^	size_t xSizeInBytes;$/;"	m	struct:HeapRegion
xStart	portable/MemMang/heap_2.c	/^static BlockLink_t xStart, xEnd;$/;"	v	file:
xStart	portable/MemMang/heap_4.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
xStart	portable/MemMang/heap_5.c	/^static BlockLink_t xStart, *pxEnd = NULL;$/;"	v	file:
xStateListItem	tasks.c	/^	ListItem_t			xStateListItem;	\/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). *\/$/;"	m	struct:tskTaskControlBlock	file:
xSuspendedTaskList	tasks.c	/^	PRIVILEGED_DATA static List_t xSuspendedTaskList;					\/*< Tasks that are currently suspended. *\/$/;"	v	file:
xTASK_PARAMETERS	include/task.h	/^typedef struct xTASK_PARAMETERS$/;"	s
xTASK_STATUS	include/task.h	/^typedef struct xTASK_STATUS$/;"	s
xTIMER	timers.c	/^} xTIMER;$/;"	t	typeref:struct:tmrTimerControl	file:
xTIME_OUT	include/task.h	/^typedef struct xTIME_OUT$/;"	s
xTaskAbortDelay	include/mpu_wrappers.h	98;"	d
xTaskAbortDelay	tasks.c	/^	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )$/;"	f
xTaskCallApplicationTaskHook	include/mpu_wrappers.h	116;"	d
xTaskCallApplicationTaskHook	tasks.c	/^	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )$/;"	f
xTaskCheckForTimeOut	include/mpu_wrappers.h	128;"	d
xTaskCheckForTimeOut	tasks.c	/^BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )$/;"	f
xTaskCreate	include/mpu_wrappers.h	91;"	d
xTaskCreate	tasks.c	/^	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,$/;"	f
xTaskCreateRestricted	include/mpu_wrappers.h	93;"	d
xTaskCreateRestricted	tasks.c	/^	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )$/;"	f
xTaskCreateStatic	include/mpu_wrappers.h	92;"	d
xTaskCreateStatic	tasks.c	/^	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,$/;"	f
xTaskGenericNotify	include/mpu_wrappers.h	121;"	d
xTaskGenericNotify	tasks.c	/^	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )$/;"	f
xTaskGenericNotifyFromISR	tasks.c	/^	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xTaskGetApplicationTaskTag	include/mpu_wrappers.h	113;"	d
xTaskGetApplicationTaskTag	tasks.c	/^	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )$/;"	f
xTaskGetCurrentTaskHandle	include/mpu_wrappers.h	126;"	d
xTaskGetCurrentTaskHandle	tasks.c	/^	TaskHandle_t xTaskGetCurrentTaskHandle( void )$/;"	f
xTaskGetHandle	include/mpu_wrappers.h	110;"	d
xTaskGetHandle	tasks.c	/^	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) \/*lint !e971 Unqualified char types are allowed for strings and single characters only. *\/$/;"	f
xTaskGetIdleTaskHandle	include/mpu_wrappers.h	117;"	d
xTaskGetIdleTaskHandle	tasks.c	/^	TaskHandle_t xTaskGetIdleTaskHandle( void )$/;"	f
xTaskGetSchedulerState	include/mpu_wrappers.h	129;"	d
xTaskGetSchedulerState	tasks.c	/^	BaseType_t xTaskGetSchedulerState( void )$/;"	f
xTaskGetTickCount	include/mpu_wrappers.h	107;"	d
xTaskGetTickCount	tasks.c	/^TickType_t xTaskGetTickCount( void )$/;"	f
xTaskGetTickCountFromISR	tasks.c	/^TickType_t xTaskGetTickCountFromISR( void )$/;"	f
xTaskHandle	include/FreeRTOS.h	826;"	d
xTaskIncrementTick	tasks.c	/^BaseType_t xTaskIncrementTick( void )$/;"	f
xTaskNotify	include/task.h	1712;"	d
xTaskNotifyAndQuery	include/task.h	1713;"	d
xTaskNotifyAndQueryFromISR	include/task.h	1804;"	d
xTaskNotifyFromISR	include/task.h	1803;"	d
xTaskNotifyGive	include/task.h	1925;"	d
xTaskNotifyStateClear	include/mpu_wrappers.h	124;"	d
xTaskNotifyStateClear	tasks.c	/^	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )$/;"	f
xTaskNotifyWait	include/mpu_wrappers.h	122;"	d
xTaskNotifyWait	tasks.c	/^	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )$/;"	f
xTaskNumber	include/task.h	/^	UBaseType_t xTaskNumber;		\/* A number unique to the task. *\/$/;"	m	struct:xTASK_STATUS
xTaskParameters	include/FreeRTOS.h	833;"	d
xTaskPriorityDisinherit	tasks.c	/^	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )$/;"	f
xTaskRemoveFromEventList	tasks.c	/^BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )$/;"	f
xTaskRemoveFromUnorderedEventList	tasks.c	/^BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )$/;"	f
xTaskResumeAll	include/mpu_wrappers.h	106;"	d
xTaskResumeAll	tasks.c	/^BaseType_t xTaskResumeAll( void )$/;"	f
xTaskResumeFromISR	tasks.c	/^	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )$/;"	f
xTaskStatusType	include/FreeRTOS.h	834;"	d
xTasksWaitingForBits	event_groups.c	/^	List_t xTasksWaitingForBits;		\/*< List of tasks waiting for a bit to be set. *\/$/;"	m	struct:xEventGroupDefinition	file:
xTasksWaitingTermination	tasks.c	/^	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				\/*< Tasks that have been deleted - but their memory not yet freed. *\/$/;"	v	file:
xTasksWaitingToReceive	queue.c	/^	List_t xTasksWaitingToReceive;	\/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xTasksWaitingToSend	queue.c	/^	List_t xTasksWaitingToSend;		\/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. *\/$/;"	m	struct:QueueDefinition	file:
xTickCount	tasks.c	/^PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;$/;"	v	file:
xTimeOnEntering	include/task.h	/^	TickType_t xTimeOnEntering;$/;"	m	struct:xTIME_OUT
xTimeOutType	include/FreeRTOS.h	831;"	d
xTimerChangePeriod	include/timers.h	667;"	d
xTimerChangePeriodFromISR	include/timers.h	1051;"	d
xTimerCreate	include/mpu_wrappers.h	159;"	d
xTimerCreate	timers.c	/^	TimerHandle_t xTimerCreate(	const char * const pcTimerName,$/;"	f
xTimerCreateStatic	include/mpu_wrappers.h	160;"	d
xTimerCreateStatic	timers.c	/^	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,$/;"	f
xTimerCreateTimerTask	timers.c	/^BaseType_t xTimerCreateTimerTask( void )$/;"	f
xTimerDelete	include/timers.h	705;"	d
xTimerGenericCommand	include/mpu_wrappers.h	169;"	d
xTimerGenericCommand	timers.c	/^BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )$/;"	f
xTimerGetExpiryTime	include/mpu_wrappers.h	168;"	d
xTimerGetExpiryTime	timers.c	/^TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )$/;"	f
xTimerGetPeriod	include/mpu_wrappers.h	167;"	d
xTimerGetPeriod	timers.c	/^TickType_t xTimerGetPeriod( TimerHandle_t xTimer )$/;"	f
xTimerGetTimerDaemonTaskHandle	include/mpu_wrappers.h	164;"	d
xTimerGetTimerDaemonTaskHandle	timers.c	/^TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )$/;"	f
xTimerHandle	include/FreeRTOS.h	835;"	d
xTimerIsTimerActive	include/mpu_wrappers.h	163;"	d
xTimerIsTimerActive	timers.c	/^BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )$/;"	f
xTimerListItem	timers.c	/^	ListItem_t				xTimerListItem;		\/*<< Standard linked list item as used by all kernel features for event management. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerParameters	timers.c	/^		TimerParameter_t xTimerParameters;$/;"	m	union:tmrTimerQueueMessage::__anon1	file:
xTimerPendFunctionCall	include/mpu_wrappers.h	165;"	d
xTimerPendFunctionCall	timers.c	/^	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )$/;"	f
xTimerPendFunctionCallFromISR	timers.c	/^	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )$/;"	f
xTimerPeriodInTicks	timers.c	/^	TickType_t				xTimerPeriodInTicks;\/*<< How quickly and often the timer expires. *\/$/;"	m	struct:tmrTimerControl	file:
xTimerQueue	timers.c	/^PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;$/;"	v	file:
xTimerReset	include/timers.h	829;"	d
xTimerResetFromISR	include/timers.h	1137;"	d
xTimerStart	include/timers.h	545;"	d
xTimerStartFromISR	include/timers.h	915;"	d
xTimerStop	include/timers.h	587;"	d
xTimerStopFromISR	include/timers.h	978;"	d
xTimerTaskHandle	timers.c	/^PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;$/;"	v	file:
xYieldPending	tasks.c	/^PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;$/;"	v	file:
